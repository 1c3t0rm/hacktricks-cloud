# Serverless.com Security

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../.gitbook/assets/image (1) (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/image (1) (1) (1) (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../.gitbook/assets/image (2) (1).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/image (2) (1).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się trikami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}

## Basic Information

### Organization

**Organizacja** to najwyższy poziom podmiotu w ekosystemie Serverless Framework. Reprezentuje **zbiorową grupę**, taką jak firma, dział lub jakikolwiek duży podmiot, który obejmuje wiele projektów, zespołów i aplikacji.

### Team

**Zespół** to użytkownicy z dostępem wewnątrz organizacji. Zespoły pomagają w organizowaniu członków na podstawie ról. **`Współpracownicy`** mogą przeglądać i wdrażać istniejące aplikacje, podczas gdy **`Administratorzy`** mogą tworzyć nowe aplikacje i zarządzać ustawieniami organizacji.

### Application

**Aplikacja** to logiczne grupowanie powiązanych usług w ramach Organizacji. Reprezentuje kompletną aplikację składającą się z wielu usług serverless, które współpracują, aby zapewnić spójną funkcjonalność.

### **Services**

**Usługa** to podstawowy komponent aplikacji Serverless. Reprezentuje cały projekt serverless, kapsułkując wszystkie funkcje, konfiguracje i zasoby potrzebne. Zwykle jest definiowana w pliku `serverless.yml`, usługa zawiera metadane, takie jak nazwa usługi, konfiguracje dostawcy, funkcje, zdarzenia, zasoby, wtyczki i zmienne niestandardowe.
```yaml
service: my-service
provider:
name: aws
runtime: nodejs14.x
functions:
hello:
handler: handler.hello
```
<details>

<summary>Funkcja</summary>

A **Funkcja** reprezentuje pojedynczą funkcję serverless, taką jak funkcja AWS Lambda. Zawiera kod, który jest wykonywany w odpowiedzi na zdarzenia.

Jest zdefiniowana w sekcji `functions` w `serverless.yml`, określając handler, runtime, zdarzenia, zmienne środowiskowe i inne ustawienia.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
```
</details>

<details>

<summary>Wydarzenie</summary>

**Wydarzenia** to wyzwalacze, które uruchamiają Twoje funkcje serverless. Określają, jak i kiedy funkcja powinna być wykonywana.

Typowe rodzaje wydarzeń to żądania HTTP, wydarzenia zaplanowane (zadania cron), wydarzenia z bazy danych, przesyłanie plików i inne.
```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
- schedule:
rate: rate(10 minutes)
```
</details>

<details>

<summary>Resource</summary>

**Zasoby** pozwalają na zdefiniowanie dodatkowych zasobów chmurowych, od których zależy Twoja usługa, takich jak bazy danych, kosze pamięci lub role IAM.

Są one określane w sekcji `resources`, często używając składni CloudFormation dla AWS.
```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
TableName: my-table
AttributeDefinitions:
- AttributeName: id
AttributeType: S
KeySchema:
- AttributeName: id
KeyType: HASH
ProvisionedThroughput:
ReadCapacityUnits: 1
WriteCapacityUnits: 1
```
</details>

<details>

<summary>Dostawca</summary>

Obiekt **Dostawca** określa dostawcę usług chmurowych (np. AWS, Azure, Google Cloud) i zawiera ustawienia konfiguracyjne istotne dla tego dostawcy.

Zawiera szczegóły takie jak środowisko uruchomieniowe, region, etap i dane uwierzytelniające.
```yaml
yamlCopy codeprovider:
name: aws
runtime: nodejs14.x
region: us-east-1
stage: dev
```
</details>

<details>

<summary>Etap i Region</summary>

Etap reprezentuje różne środowiska (np. rozwój, staging, produkcja), w których Twoja usługa może być wdrożona. Umożliwia to konfiguracje i wdrożenia specyficzne dla środowiska.
```yaml
provider:
stage: dev
```
Region określa geograficzny obszar, w którym Twoje zasoby będą wdrażane. Jest to ważne z uwagi na opóźnienia, zgodność i dostępność.
```yaml
provider:
region: us-west-2
```
</details>

<details>

<summary>Wtyczki</summary>

**Wtyczki** rozszerzają funkcjonalność Frameworka Serverless, dodając nowe funkcje lub integrując się z innymi narzędziami i usługami. Są definiowane w sekcji `plugins` i instalowane za pomocą npm.
```yaml
plugins:
- serverless-offline
- serverless-webpack
```
</details>

<details>

<summary>Warstwy</summary>

**Warstwy** pozwalają na pakowanie i zarządzanie wspólnym kodem lub zależnościami oddzielnie od twoich funkcji. To promuje ponowne użycie i zmniejsza rozmiary pakietów wdrożeniowych. Są definiowane w sekcji `layers` i są odniesione przez funkcje.
```yaml
layers:
commonLibs:
path: layer-common
functions:
hello:
handler: handler.hello
layers:
- { Ref: CommonLibsLambdaLayer }
```
</details>

<details>

<summary>Zmienne i Zmienne Niestandardowe</summary>

**Zmienne** umożliwiają dynamiczną konfigurację, pozwalając na użycie miejsc zastępczych, które są rozwiązywane w czasie wdrażania.

*   **Składnia:** składnia `${variable}` może odnosić się do zmiennych środowiskowych, zawartości plików lub innych parametrów konfiguracyjnych.

```yaml
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```

-   **Zmienne Niestandardowe:** Sekcja `custom` jest używana do definiowania zmiennych i konfiguracji specyficznych dla użytkownika, które mogą być ponownie używane w całym pliku `serverless.yml`.

```yaml
custom:
tableName: my-dynamodb-table
stage: ${opt:stage, 'dev'}
```

</details>

<details>

<summary>Wyjścia</summary>

**Wyjścia** definiują wartości, które są zwracane po wdrożeniu usługi, takie jak ARNy zasobów, punkty końcowe lub inne przydatne informacje. Są one określone w sekcji `outputs` i często używane do udostępniania informacji innym usługom lub do łatwego dostępu po wdrożeniu.
```yaml
¡outputs:
ApiEndpoint:
Description: "API Gateway endpoint URL"
Value:
Fn::Join:
- ""
- - "https://"
- Ref: ApiGatewayRestApi
- ".execute-api."
- Ref: AWS::Region
- ".amazonaws.com/"
- Ref: AWS::Stage
```
</details>

<details>

<summary>Role i uprawnienia IAM</summary>

**Role i uprawnienia IAM** definiują dane uwierzytelniające i prawa dostępu do Twoich funkcji i innych zasobów. Są zarządzane w ramach ustawień `provider` lub indywidualnych funkcji, aby określić niezbędne uprawnienia.
```yaml
provider:
iamRoleStatements:
- Effect: Allow
Action:
- dynamodb:Query
- dynamodb:Scan
Resource: arn:aws:dynamodb:${self:provider.region}:*:table/my-table
```
</details>

<details>

<summary>Zmienne Środowiskowe</summary>

**Zmienne** pozwalają na przekazywanie ustawień konfiguracyjnych i sekretów do twoich funkcji bez ich twardego kodowania. Są definiowane w sekcji `environment` dla dostawcy lub poszczególnych funkcji.
```yaml
provider:
environment:
STAGE: ${self:provider.stage}
functions:
hello:
handler: handler.hello
environment:
TABLE_NAME: ${self:custom.tableName}
```
</details>

<details>

<summary>Dependencies</summary>

**Dependencies** zarządzają zewnętrznymi bibliotekami i modułami, których potrzebują Twoje funkcje. Zazwyczaj są obsługiwane za pomocą menedżerów pakietów, takich jak npm lub pip, i pakowane z Twoim pakietem wdrożeniowym przy użyciu narzędzi lub wtyczek, takich jak `serverless-webpack`.
```yaml
plugins:
- serverless-webpack
```
</details>

<details>

<summary>Hooks</summary>

**Hooks** pozwalają na uruchamianie niestandardowych skryptów lub poleceń w określonych punktach cyklu życia wdrożenia. Są definiowane za pomocą wtyczek lub w pliku `serverless.yml`, aby wykonywać działania przed lub po wdrożeniach.
```yaml
custom:
hooks:
before:deploy:deploy: echo "Starting deployment..."
```
</details>

### Tutorial

To jest podsumowanie oficjalnego samouczka [**z dokumentacji**](https://www.serverless.com/framework/docs/tutorial):

1. Utwórz konto AWS (Serverless.com zaczyna w infrastrukturze AWS)
2. Utwórz konto w serverless.com
3. Utwórz aplikację:
```bash
# Create temp folder for the tutorial
mkdir /tmp/serverless-tutorial
cd /tmp/serverless-tutorial

# Install Serverless cli
npm install -g serverless

# Generate template
serverless #Choose first one (AWS / Node.js / HTTP API)
## Indicate a name like "Tutorial"
## Login/Register
## Create A New App
## Indicate a name like "tutorialapp)
```
To powinno stworzyć **aplikację** o nazwie `tutorialapp`, którą możesz sprawdzić w [serverless.com](serverless.com-security.md) oraz folder o nazwie `Tutorial` z plikiem **`handler.js`** zawierającym kod JS z kodem `helloworld` oraz plikiem **`serverless.yml`** deklarującym tę funkcję:

{% tabs %}
{% tab title="handler.js" %}
```javascript
exports.hello = async (event) => {
return {
statusCode: 200,
body: JSON.stringify({
message: "Go Serverless v4! Your function executed successfully!",
}),
};
};
```
{% endtab %}

{% tab title="serverless.yml" %}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
```
{% endtab %}
{% endtabs %}

4. Utwórz dostawcę AWS, przechodząc do **dashboardu** pod `https://app.serverless.com/<org name>/settings/providers?providerId=new&provider=aws`.
1. Aby dać `serverless.com` dostęp do AWS, poprosi o uruchomienie stosu cloudformation przy użyciu tego pliku konfiguracyjnego (w momencie pisania tego tekstu): [https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml](https://serverless-framework-template.s3.amazonaws.com/roleTemplate.yml)
2. Ten szablon generuje rolę o nazwie **`SFRole-<ID>`** z **`arn:aws:iam::aws:policy/AdministratorAccess`** dla konta z tożsamością zaufania, która pozwala na dostęp do roli konta `Serverless.com` AWS.

<details>

<summary>Yaml roleTemplate</summary>
```yaml
Description: This stack creates an IAM role that can be used by Serverless Framework for use in deployments.
Resources:
SFRole:
Type: AWS::IAM::Role
Properties:
AssumeRolePolicyDocument:
Version: '2012-10-17'
Statement:
- Effect: Allow
Principal:
AWS: arn:aws:iam::486128539022:root
Action:
- sts:AssumeRole
Condition:
StringEquals:
sts:ExternalId: !Sub 'ServerlessFramework-${OrgUid}'
Path: /
RoleName: !Ref RoleName
ManagedPolicyArns:
- arn:aws:iam::aws:policy/AdministratorAccess
ReporterFunction:
Type: Custom::ServerlessFrameworkReporter
Properties:
ServiceToken: 'arn:aws:lambda:us-east-1:486128539022:function:sp-providers-stack-reporter-custom-resource-prod-tmen2ec'
OrgUid: !Ref OrgUid
RoleArn: !GetAtt SFRole.Arn
Alias: !Ref Alias
Outputs:
SFRoleArn:
Description: 'ARN for the IAM Role used by Serverless Framework'
Value: !GetAtt SFRole.Arn
Parameters:
OrgUid:
Description: Serverless Framework Org Uid
Type: String
Alias:
Description: Serverless Framework Provider Alias
Type: String
RoleName:
Description: Serverless Framework Role Name
Type: String
```
</details>

<details>

<summary>Relacja Zaufania</summary>
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::486128539022:root"
},
"Action": "sts:AssumeRole",
"Condition": {
"StringEquals": {
"sts:ExternalId": "ServerlessFramework-7bf7ddef-e1bf-43eb-a111-4d43e0894ccb"
}
}
}
]
}
```
</details>

5. Tutorial prosi o utworzenie pliku `createCustomer.js`, który zasadniczo utworzy nowy punkt końcowy API obsługiwany przez nowy plik JS i prosi o modyfikację pliku `serverless.yml`, aby wygenerować **nową tabelę DynamoDB**, zdefiniować **zmienną środowiskową**, rolę, która będzie używać wygenerowanych lambd.

{% tabs %}
{% tab title="createCustomer.js" %}
```javascript
'use strict'
const AWS = require('aws-sdk')
module.exports.createCustomer = async (event) => {
const body = JSON.parse(Buffer.from(event.body, 'base64').toString())
const dynamoDb = new AWS.DynamoDB.DocumentClient()
const putParams = {
TableName: process.env.DYNAMODB_CUSTOMER_TABLE,
Item: {
primary_key: body.name,
email: body.email,
},
}
await dynamoDb.put(putParams).promise()
return {
statusCode: 201,
}
}
```
{% endtab %}

{% tab title="serverless.yml" %}
```yaml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: testing12342
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: tutorialapp
# "service" is the name of this project. This will also be added to your AWS resource names.
service: Tutorial

provider:
name: aws
runtime: nodejs20.x
environment:
DYNAMODB_CUSTOMER_TABLE: ${self:service}-customerTable-${sls:stage}
iam:
role:
statements:
- Effect: 'Allow'
Action:
- 'dynamodb:PutItem'
- 'dynamodb:Get*'
- 'dynamodb:Scan*'
- 'dynamodb:UpdateItem'
- 'dynamodb:DeleteItem'
Resource: arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:service}-customerTable-${sls:stage}

functions:
hello:
handler: handler.hello
events:
- httpApi:
path: /
method: get
createCustomer:
handler: createCustomer.createCustomer
events:
- httpApi:
path: /
method: post

resources:
Resources:
CustomerTable:
Type: AWS::DynamoDB::Table
Properties:
AttributeDefinitions:
- AttributeName: primary_key
AttributeType: S
BillingMode: PAY_PER_REQUEST
KeySchema:
- AttributeName: primary_key
KeyType: HASH
TableName: ${self:service}-customerTable-${sls:stage}
```
{% endtab %}
{% endtabs %}

6. Wdróż go, uruchamiając **`serverless deploy`**
1. Wdrożenie zostanie przeprowadzone za pomocą CloudFormation Stack
2. Zauważ, że **lambdy są udostępniane za pośrednictwem API gateway** a nie za pomocą bezpośrednich adresów URL
7. **Przetestuj to**
1. Poprzedni krok wydrukuje **adresy URL**, pod którymi Twoje funkcje lambda punktów końcowych API zostały wdrożone

## Przegląd bezpieczeństwa Serverless.com

### **Źle skonfigurowane role IAM i uprawnienia**

Zbyt szerokie role IAM mogą przyznać nieautoryzowany dostęp do zasobów chmurowych, prowadząc do naruszeń danych lub manipulacji zasobami.

#### **Strategie łagodzenia**

*   **Zasada najmniejszych uprawnień:** Przydzielaj tylko niezbędne uprawnienia do każdej funkcji.

```yaml
provider:
iamRoleStatements:
- Effect: Allow
Action:
- dynamodb:Query
- dynamodb:Scan
Resource: arn:aws:dynamodb:${self:provider.region}:*:table/my-table
```
* **Używaj oddzielnych ról:** Rozróżniaj role w zależności od wymagań funkcji.

***

### **Niezabezpieczone sekrety i zarządzanie konfiguracją**

Przechowywanie wrażliwych informacji (np. kluczy API, poświadczeń bazy danych) bezpośrednio w `serverless.yml` lub kodzie może prowadzić do ujawnienia, jeśli repozytoria zostaną skompromitowane lub jeśli dostęp do AWS zostanie naruszony, ponieważ będą one czytelne z konfiguracji lambd.

#### **Strategie łagodzenia**

*   **Zmienne środowiskowe:** Wstrzykuj sekrety w czasie wykonywania bez twardego kodowania.

```yaml
provider:
environment:
DB_PASSWORD: ${ssm:/aws/reference/secretsmanager/my-db-password~true}
```
* **Integracja z Menedżerem Sekretów:** Używaj usług takich jak **AWS Secrets Manager**, **Azure Key Vault** lub **HashiCorp Vault**.
* **Szyfrowane zmienne:** Wykorzystaj funkcje szyfrowania Frameworka Serverless dla wrażliwych danych.
* **Kontrola dostępu:** Ogranicz dostęp do sekretów w zależności od ról.
* **Unikaj logowania sekretów:** Upewnij się, że sekrety nie są ujawniane w logach ani komunikatach o błędach.

***

### **Wrażliwy kod i zależności**

Nieaktualne lub niezabezpieczone zależności mogą wprowadzać luki, podczas gdy niewłaściwe przetwarzanie danych wejściowych może prowadzić do ataków typu injection.

#### **Strategie łagodzenia**

*   **Zarządzanie zależnościami:** Regularnie aktualizuj zależności i skanuj pod kątem luk.

```yaml
plugins:
- serverless-webpack
- serverless-plugin-snyk
```
* **Walidacja danych wejściowych:** Wprowadź ścisłą walidację i sanitację wszystkich danych wejściowych.
* **Przeglądy kodu:** Przeprowadzaj dokładne przeglądy, aby zidentyfikować luki w zabezpieczeniach.
* **Analiza statyczna:** Używaj narzędzi do wykrywania luk w kodzie.

***

### **Niewystarczające logowanie i monitorowanie**

Bez odpowiedniego logowania i monitorowania, złośliwe działania mogą pozostać niezauważone, opóźniając reakcję na incydenty.

#### **Strategie łagodzenia**

*   **Centralne logowanie:** Agreguj logi za pomocą usług takich jak **AWS CloudWatch** lub **Datadog**.

```yaml
plugins:
- serverless-plugin-datadog
```
* **Włącz szczegółowe logowanie:** Zbieraj istotne informacje bez ujawniania wrażliwych danych.
* **Ustaw alerty:** Skonfiguruj alerty dla podejrzanych działań lub anomalii.
* **Regularne monitorowanie:** Ciągłe monitorowanie logów i metryk w poszukiwaniu potencjalnych incydentów bezpieczeństwa.

***

### **Niezabezpieczone konfiguracje API Gateway**

Otwarte lub niewłaściwie zabezpieczone API mogą być wykorzystywane do nieautoryzowanego dostępu, ataków Denial of Service (DoS) lub ataków typu cross-site.

#### **Strategie łagodzenia**

*   **Uwierzytelnianie i autoryzacja:** Wprowadź solidne mechanizmy, takie jak OAuth, klucze API lub JWT.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
authorizer: aws_iam
```
*   **Ograniczenie liczby żądań i throttling:** Zapobiegaj nadużyciom, ograniczając liczbę żądań.

```yaml
provider:
apiGateway:
throttle:
burstLimit: 200
rateLimit: 100
```
*   **Zabezpieczona konfiguracja CORS:** Ogranicz dozwolone źródła, metody i nagłówki.

```yaml
functions:
hello:
handler: handler.hello
events:
- http:
path: hello
method: get
cors:
origin: https://yourdomain.com
headers:
- Content-Type
```
* **Używaj zapór aplikacji webowych (WAF):** Filtruj i monitoruj żądania HTTP w poszukiwaniu złośliwych wzorców.

***

### **Niewystarczająca izolacja funkcji**

Wspólne zasoby i niewystarczająca izolacja mogą prowadzić do eskalacji uprawnień lub niezamierzonych interakcji między funkcjami.

#### **Strategie łagodzenia**

* **Izoluj funkcje:** Przydzielaj odrębne zasoby i role IAM, aby zapewnić niezależne działanie.
* **Podział zasobów:** Używaj oddzielnych baz danych lub koszyków pamięci dla różnych funkcji.
*   **Używaj VPC:** Wdrażaj funkcje w Wirtualnych Chmurach Prywatnych dla lepszej izolacji sieci.

```yaml
provider:
vpc:
securityGroupIds:
- sg-xxxxxxxx
subnetIds:
- subnet-xxxxxx
```
* **Ogranicz uprawnienia funkcji:** Upewnij się, że funkcje nie mogą uzyskiwać dostępu do zasobów innych funkcji, chyba że jest to wyraźnie wymagane.

***

### **Niewystarczająca ochrona danych**

Niezaszyfrowane dane w spoczynku lub w tranzycie mogą być narażone na ujawnienie, prowadząc do naruszeń danych lub manipulacji.

#### **Strategie łagodzenia**

*   **Szyfruj dane w spoczynku:** Wykorzystaj funkcje szyfrowania usług chmurowych.

```yaml
resources:
Resources:
MyDynamoDBTable:
Type: AWS::DynamoDB::Table
Properties:
SSESpecification:
SSEEnabled: true
```
* **Szyfruj dane w tranzycie:** Używaj HTTPS/TLS dla wszystkich transmisji danych.
* **Zabezpiecz komunikację API:** Wymuszaj protokoły szyfrowania i weryfikuj certyfikaty.
* **Zarządzaj kluczami szyfrującymi w sposób bezpieczny:** Używaj zarządzanych usług kluczy i regularnie rotuj klucze.

***

### **Brak odpowiedniego zarządzania błędami**

Szczegółowe komunikaty o błędach mogą ujawniać wrażliwe informacje o infrastrukturze lub kodzie, podczas gdy nieobsługiwane wyjątki mogą prowadzić do awarii aplikacji.

#### **Strategie łagodzenia**

*   **Ogólne komunikaty o błędach:** Unikaj ujawniania wewnętrznych szczegółów w odpowiedziach o błędach.

```javascript
javascriptCopy code// Przykład w Node.js
exports.hello = async (event) => {
try {
// Logika funkcji
} catch (error) {
console.error(error);
return {
statusCode: 500,
body: JSON.stringify({ message: 'Internal Server Error' }),
};
}
};
```
* **Centralne zarządzanie błędami:** Zarządzaj i sanitizuj błędy konsekwentnie w wszystkich funkcjach.
* **Monitoruj i loguj błędy:** Śledź i analizuj błędy wewnętrznie, nie ujawniając szczegółów użytkownikom końcowym.

***

### **Niezabezpieczone praktyki wdrożeniowe**

Ujawniłe konfiguracje wdrożeniowe lub nieautoryzowany dostęp do pipeline'ów CI/CD mogą prowadzić do wdrożeń złośliwego kodu lub błędnych konfiguracji.

#### **Strategie łagodzenia**

* **Zabezpiecz pipeline'y CI/CD:** Wprowadź ścisłe kontrole dostępu, uwierzytelnianie wieloskładnikowe (MFA) i regularne audyty.
* **Przechowuj konfigurację w sposób bezpieczny:** Utrzymuj pliki wdrożeniowe wolne od twardo zakodowanych sekretów i wrażliwych danych.
* **Używaj narzędzi bezpieczeństwa Infrastructure as Code (IaC):** Wykorzystuj narzędzia takie jak **Checkov** lub **Terraform Sentinel** do egzekwowania polityk bezpieczeństwa.
* **Niezmienność wdrożeń:** Zapobiegaj nieautoryzowanym zmianom po wdrożeniu, przyjmując praktyki niezmiennej infrastruktury.

***

### **Luki w wtyczkach i rozszerzeniach**

Używanie nieweryfikowanych lub złośliwych wtyczek stron trzecich może wprowadzać luki w Twoich aplikacjach serverless.

#### **Strategie łagodzenia**

* **Dokładnie weryfikuj wtyczki:** Oceń bezpieczeństwo wtyczek przed integracją, preferując te z wiarygodnych źródeł.
* **Ogranicz użycie wtyczek:** Używaj tylko niezbędnych wtyczek, aby zminimalizować powierzchnię ataku.
* **Monitoruj aktualizacje wtyczek:** Utrzymuj wtyczki zaktualizowane, aby korzystać z poprawek bezpieczeństwa.
* **Izoluj środowiska wtyczek:** Uruchamiaj wtyczki w izolowanych środowiskach, aby ograniczyć potencjalne kompromitacje.

***

### **Ujawnienie wrażliwych punktów końcowych**

Funkcje dostępne publicznie lub nieograniczone API mogą być wykorzystywane do nieautoryzowanych operacji.

#### **Strategie łagodzenia**

* **Ogranicz dostęp do funkcji:** Używaj VPC, grup zabezpieczeń i reguł zapory, aby ograniczyć dostęp do zaufanych źródeł.
* **Wprowadź solidne uwierzytelnianie:** Upewnij się, że wszystkie ujawnione punkty końcowe wymagają odpowiedniego uwierzytelniania i autoryzacji.
* **Używaj API Gateway w sposób bezpieczny:** Konfiguruj API Gateway, aby egzekwować polityki bezpieczeństwa, w tym walidację danych wejściowych i ograniczenie liczby żądań.
* **Wyłącz nieużywane punkty końcowe:** Regularnie przeglądaj i wyłączaj wszelkie punkty końcowe, które nie są już używane.

***

### **Nadmierne uprawnienia dla członków zespołu i zewnętrznych współpracowników**

Przyznawanie nadmiernych uprawnień członkom zespołu i zewnętrznym współpracownikom może prowadzić do nieautoryzowanego dostępu, naruszeń danych i nadużyć zasobów. Ryzyko to wzrasta w środowiskach, w których wiele osób ma różne poziomy dostępu, zwiększając powierzchnię ataku i potencjalne zagrożenia wewnętrzne.

#### **Strategie łagodzenia**

* **Zasada najmniejszych uprawnień:** Upewnij się, że członkowie zespołu i współpracownicy mają tylko te uprawnienia, które są niezbędne do wykonywania ich zadań.

***

### **Bezpieczeństwo kluczy dostępu i kluczy licencyjnych**

**Klucze dostępu** i **klucze licencyjne** to krytyczne poświadczenia używane do uwierzytelniania i autoryzacji interakcji z interfejsem CLI Frameworka Serverless.

* **Klucze licencyjne:** To unikalne identyfikatory wymagane do uwierzytelnienia dostępu do Frameworka Serverless wersji 4, które umożliwiają logowanie za pomocą CLI.
* **Klucze dostępu:** Poświadczenia, które pozwalają interfejsowi CLI Frameworka Serverless uwierzytelnić się z Dashboardem Frameworka Serverless. Podczas logowania za pomocą CLI `serverless` klucz dostępu zostanie **wygenerowany i zapisany na laptopie**. Możesz go również ustawić jako zmienną środowiskową o nazwie `SERVERLESS_ACCESS_KEY`.

#### **Ryzyka bezpieczeństwa**

1. **Ujawnienie przez repozytoria kodu:**
* Twarde kodowanie lub przypadkowe zatwierdzanie kluczy dostępu i kluczy licencyjnych do systemów kontroli wersji może prowadzić do nieautoryzowanego dostępu.
2. **Niezabezpieczone przechowywanie:**
* Przechowywanie kluczy w postaci tekstu jawnego w zmiennych środowiskowych lub plikach konfiguracyjnych bez odpowiedniego szyfrowania zwiększa prawdopodobieństwo wycieku.
3. **Niewłaściwa dystrybucja:**
* Udostępnianie kluczy przez niezabezpieczone kanały (np. e-mail, czat) może skutkować ich przechwyceniem przez złośliwe podmioty.
4. **Brak rotacji:**
* Nieregularna rotacja kluczy wydłuża okres narażenia, jeśli klucze zostaną skompromitowane.
5. **Nadmierne uprawnienia:**
* Klucze z szerokimi uprawnieniami mogą być wykorzystywane do wykonywania nieautoryzowanych działań w wielu zasobach.

{% hint style="success" %}
Ucz się i ćwicz hacking AWS:<img src="../.gitbook/assets/image (1) (1) (1) (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/image (1) (1) (1) (1).png" alt="" data-size="line">\
Ucz się i ćwicz hacking GCP: <img src="../.gitbook/assets/image (2) (1).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/image (2) (1).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **Dziel się sztuczkami hackingowymi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}
