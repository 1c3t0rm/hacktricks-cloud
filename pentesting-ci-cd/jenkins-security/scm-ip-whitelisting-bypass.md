# Bypass de Lista Blanca de IP de SCM

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Esta p√°gina fue copiada de [https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## Introducci√≥n

Muchas organizaciones combinan sistemas de gesti√≥n de control de fuente basados en **SaaS** (como GitHub o GitLab) con una soluci√≥n **CI** interna y autoalojada (por ejemplo, Jenkins, TeamCity) permitiendo que estos sistemas CI **reciban eventos de webhook desde el proveedor de control de fuente SaaS**, con el simple prop√≥sito de desencadenar trabajos de pipeline.

Por lo tanto, las organizaciones **incluyen en la lista blanca** los rangos de **IP** de los **SCM** permiti√©ndoles alcanzar el sistema CI **interno** con **webhooks**. Sin embargo, nota c√≥mo **cualquiera** puede crear una **cuenta** en Github o Gitlab y hacer que **active un webhook** que podr√≠a enviar una solicitud a ese **sistema CI interno**.

Adem√°s, ten en cuenta que mientras que el rango de IP del servicio de webhook del proveedor de SCM estaba abierto en el firewall de la organizaci√≥n para **permitir que las solicitudes de webhook desencadenen pipelines** ‚Äì esto **no significa** que las solicitudes de webhook no puedan ser **dirigidas hacia otros puntos finales de CI**, adem√°s de los que regularmente escuchan eventos de webhook. Podemos intentar acceder a estos puntos finales para **ver datos valiosos como usuarios**, **pipelines**, **salida de consola** de trabajos de pipeline, o si tenemos la suerte de encontrarnos con una instancia que otorga privilegios de administrador a usuarios no autenticados (s√≠, sucede), podemos acceder a las **secciones de configuraciones y credenciales**.

### Escenario

Imagina un servicio de **Jenkins** que solo **permite** que las IPs de **GitHub** y **GitLab** lo alcancen **externamente**.

En este escenario, un atacante activar√° webhooks arbitrarios en GitHub y GitLab para iniciar sesi√≥n en Jenkins y extraer informaci√≥n.

### Limitaciones Comunes de Webhooks

* **Solo solicitudes POST**: Los webhooks generalmente solo te permiten enviar solicitudes POST, sin embargo, algunos **puntos finales** con informaci√≥n **interesante** necesitan ser accedidos a trav√©s de **solicitudes GET**.
* Si el Post es **respondido con una redirecci√≥n** podr√≠a seguirla.
* Algunos CI (Jenkins) permiten tener un **par√°metro GET indicando d√≥nde redirigir al cliente** una vez que logr√≥ iniciar sesi√≥n, puedes usar esto para redirigirlo a una p√°gina espec√≠fica con un Get.
* **No se puede controlar el cuerpo de la solicitud POST**: Si quieres enviar datos espec√≠ficos en el cuerpo del POST, no puedes.
* **Tokens CSRF**: Si el punto final interesante espera tokens CSRF, no podr√°s extraerlos y proporcionarlos.

## Webhooks de GitHub

### Abusando del inicio de sesi√≥n en Jenkins

El inicio de sesi√≥n requiere enviar una **solicitud POST**. Elegir apuntar al punto final de inicio de sesi√≥n resuelve el desaf√≠o de mantener tokens CSRF, ya que esta solicitud espec√≠fica no los requiere. Pero a√∫n enfrentamos el otro desaf√≠o, ya que nuestras habilidades para **modificar el cuerpo de la solicitud siguen siendo limitadas**.

Una solicitud de inicio de sesi√≥n en Jenkins se ve de la siguiente manera:
```
POST /j_acegi_security_check HTTP/1.1
Host: jenkins.example-domain.com
[...]

j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in
```
Necesitamos **enviar las credenciales que forzamos bruscamente de alguna manera**.\
Afortunadamente, el punto final de inicio de sesi√≥n de Jenkins **acepta** una solicitud POST con los **campos enviados como par√°metros de consulta**:
```
POST /j_acegi_security_check?j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in HTTP/1.1
Host: jenkins.example-domain.com
[...]

[webhook json in body of request]
```
As√≠ que, ¬øc√≥mo podemos hacer que funcione? Podemos **crear un nuevo webhook en GitHub**, estableciendo la **URL de solicitud de inicio de sesi√≥n de Jenkins como la URL de carga √∫til**. Luego podemos crear una automatizaci√≥n usando la API de GitHub para **forzar bruscamente la contrase√±a de la cuenta de usuario**, modificando el campo de contrase√±a, activando el webhook e inspeccionando la respuesta en el registro de eventos del webhook del repositorio.
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=therealpassword&from=%2F&Submit=Sign+in
```
<figure><img src="../../.gitbook/assets/image (7) (1) (1) (2).png" alt=""><figcaption></figcaption></figure>

Disparamos el webhook y vemos los resultados. Todos los proveedores de SCM muestran la solicitud HTTP y la respuesta enviadas a trav√©s del webhook en su UI.
Si el intento de inicio de sesi√≥n falla, somos redirigidos a la p√°gina de error de inicio de sesi√≥n.

<figure><img src="../../.gitbook/assets/image (6) (1) (2).png" alt=""><figcaption></figcaption></figure>

Pero si el **inicio de sesi√≥n es exitoso**, somos redirigidos a la p√°gina principal de Jenkins, y se establece una **cookie de sesi√≥n**.

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (2).png" alt=""><figcaption></figcaption></figure>

Entonces, ¬°podemos **fuerza bruta las credenciales de Jenkins y obtener una cookie de sesi√≥n!**
Sin embargo, estamos un poco limitados: solo podemos **enviar una solicitud sin estado cada vez**, y la **cookie no se puede adjuntar** a nuestra solicitud, ya que no podemos controlar las cabeceras.

Otra opci√≥n ser√≠a intentar obtener un **token de acceso de Jenkins**, que se puede adjuntar en la URL y usar para enviar solicitudes POST a Jenkins sin la necesidad de agregar un token CSRF. Esta opci√≥n es un poco m√°s compleja ya que requiere que un atacante encuentre de alguna manera tanto un CI autoalojado que solo es accesible desde rangos de IP de SCM y tambi√©n obtenga un token de acceso v√°lido a ese CI. As√≠ que por el momento, nos centraremos en escenarios m√°s pr√°cticos.

## Webhooks de GitLab

### Abusando del Inicio de Sesi√≥n de Jenkins

Intentemos enviar la misma solicitud, pero esta vez a trav√©s de GitLab. Debido a las mismas limitaciones, enviamos la **misma solicitud POST exacta, agregando las credenciales como par√°metros de consulta**.

<figure><img src="../../.gitbook/assets/image (2) (2) (1).png" alt=""><figcaption></figcaption></figure>

Disparamos la solicitud, pero a diferencia de GitHub, la respuesta es 200. Como en el √∫ltimo ejemplo, usamos **el servicio de webhook de GitLab para fuerza bruta de un usuario y obtener una cookie de sesi√≥n**, pero esta vez, el contenido de la respuesta de Jenkins se retransmiti√≥ al UI de GitLab, proporcion√°ndonos esencialmente **el contenido completo de la p√°gina principal de Jenkins.**
Esto se debe a que **GitLab sigui√≥ la redirecci√≥n** agregando la **Cookie** a la solicitud:

<figure><img src="../../.gitbook/assets/image (4) (1) (2).png" alt=""><figcaption></figcaption></figure>

Esto significa que podemos:

1. fuerza bruta de usuarios y descubrir credenciales v√°lidas,
2. usar las credenciales v√°lidas contra la p√°gina de inicio de sesi√≥n para iniciar sesi√≥n con √©xito,
3. obtener el contenido de la p√°gina principal interna de Jenkins.

### Obteniendo Datos Internos de Jenkins

El **inicio de sesi√≥n de Jenkins acepta un par√°metro de redirecci√≥n** ‚Äì ‚Äú_from_‚Äù. Originalmente utilizado para **redirigir a los usuarios a la p√°gina a la que apuntaban despu√©s de iniciar sesi√≥n**, pero en nuestro caso, una caracter√≠stica que podemos abusar para enviar una solicitud GET adjunta con una cookie de sesi√≥n a una p√°gina interna de Jenkins de nuestra elecci√≥n. Veamos c√≥mo:

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (2).png" alt=""><figcaption></figcaption></figure>

1. Establece un webhook con la siguiente URL:
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=secretpass123&from=/job/prod_pipeline/1/consoleText&Submit=Sign+in
```
Una solicitud POST se env√≠a a Jenkins y la autenticaci√≥n tiene √©xito.

* Recibimos una respuesta de redirecci√≥n 302, con una cookie de sesi√≥n y una redirecci√≥n a la p√°gina de salida de la consola del trabajo.
* El servicio de webhook de GitLab sigue autom√°ticamente la redirecci√≥n con una solicitud GET enviada a la p√°gina de salida de la consola del trabajo, junto con la cookie de sesi√≥n que se agrega a la solicitud:
```
http://jenkins.example-domain.com/job/prod_pipeline/1/consoleText
```
* La salida de la consola de trabajo se env√≠a y se presenta en el registro de eventos de webhook de GitLab del atacante.

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

Es importante mencionar aqu√≠ que Jenkins puede **configurarse para permitir el acceso a componentes internos sin autenticaci√≥n**, o de manera que solo los usuarios autenticados puedan acceder a los componentes internos. ¬øC√≥mo nos afecta esto?

* Si **no hay autenticaci√≥n** configurada, podemos hacer que el **servicio de webhook de GitLab acceda a cualquier p√°gina interna en el CI**, capturar la respuesta y present√°rnosla.
* Si la autenticaci√≥n est√° configurada, podemos intentar forzar bruscamente a un usuario y luego usar las credenciales para acceder a cualquier p√°gina interna (como en el punto anterior).

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
