# Contournement de la liste blanche d'IP SCM

<details>

<summary><strong>Apprenez le hacking AWS de zéro à héros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncée dans HackTricks** ou **télécharger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* Découvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** 💬 [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-moi** sur **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux dépôts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Cette page a été copiée de [https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## Introduction

De nombreuses organisations combinent des systèmes de gestion de contrôle de source basés sur **SaaS** (comme GitHub ou GitLab) avec une solution **CI** interne et auto-hébergée (par exemple, Jenkins, TeamCity), permettant à ces systèmes CI de **recevoir des événements webhook des fournisseurs de contrôle de source SaaS**, dans le simple but de déclencher des jobs de pipeline.

Par conséquent, les organisations **mettent en liste blanche** les plages d'**IP** du **SCM** leur permettant d'atteindre le système CI **interne** avec des **webhooks**. Cependant, notez comment **n'importe qui** peut créer un **compte** sur Github ou Gitlab et le faire **déclencher un webhook** qui pourrait envoyer une requête à ce système CI **interne**.

De plus, notez que bien que la plage d'IP du service de webhook du fournisseur SCM ait été ouverte dans le pare-feu de l'organisation pour **permettre aux requêtes webhook de déclencher des pipelines** – cela ne **signifie pas** que les requêtes webhook ne peuvent pas être **dirigées vers d'autres points de terminaison CI**, en plus de ceux qui écoutent régulièrement les événements webhook. Nous pouvons essayer d'accéder à ces points de terminaison pour **voir des données précieuses comme les utilisateurs**, **les pipelines**, **la sortie console** des jobs de pipeline, ou si nous avons la chance de tomber sur une instance qui accorde des privilèges d'administrateur aux utilisateurs non authentifiés (oui, cela arrive), nous pouvons accéder aux **sections de configurations et d'identifiants**.

### Scénario

Imaginez un service **Jenkins** qui **autorise** uniquement les IP de **GitHub** et **GitLab** à l'atteindre **de l'extérieur**.

Dans ce scénario, un attaquant déclenchera des webhooks arbitraires dans GitHub et GitLab pour se connecter à Jenkins et extraire des informations.

### Limitations courantes des Webhooks

* **Uniquement des requêtes POST** : Les webhooks ne vous permettent généralement que d'envoyer des requêtes POST, cependant, certains **points de terminaison** avec des informations **intéressantes** doivent être accessibles via des requêtes **GET**.
* Si le Post est **répondu par une redirection**, il pourrait la suivre.
* Certains CI (Jenkins) permettent d'avoir un **paramètre GET indiquant où rediriger le client** une fois qu'il a réussi à se connecter, vous pouvez utiliser cela pour le rediriger vers une page spécifique avec un Get.
* **Impossible de contrôler le corps de la requête POST** : Si vous souhaitez envoyer des données spécifiques dans le corps du POST, vous ne pouvez pas.
* **Jetons CSRF** : Si le point de terminaison intéressant attend des jetons CSRF, vous ne pourrez pas les extraire et les fournir.

## Webhooks GitHub

### Abuser de la connexion Jenkins

La connexion nécessite l'envoi d'une **requête POST**. Choisir de cibler le point de terminaison de connexion résout le défi de détenir des jetons CSRF, car cette requête spécifique n'en nécessite pas. Mais nous sommes toujours confrontés à l'autre défi, car nos capacités à **modifier le corps de la requête restent limitées**.

Une requête de connexion Jenkins se présente comme suit :
```
POST /j_acegi_security_check HTTP/1.1
Host: jenkins.example-domain.com
[...]

j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in
```
Nous devons **envoyer les identifiants que nous avons forcés par brute force d'une manière ou d'une autre**.\
Heureusement, le point de terminaison de connexion Jenkins **accepte** une requête POST avec les **champs envoyés en tant que paramètres de requête** :
```
POST /j_acegi_security_check?j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in HTTP/1.1
Host: jenkins.example-domain.com
[...]

[webhook json in body of request]
```
Alors, comment pouvons-nous le faire fonctionner ? Nous pouvons **créer un nouveau webhook dans GitHub**, en définissant **l'URL de demande de connexion Jenkins comme URL de payload**. Nous pouvons ensuite créer une automatisation en utilisant l'API GitHub pour **forcer brutalement le mot de passe du compte utilisateur**, en modifiant le champ du mot de passe, en déclenchant le webhook et en inspectant la réponse dans le journal des événements webhook du dépôt.
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=therealpassword&from=%2F&Submit=Sign+in
```
```markdown
Nous déclenchons le webhook et observons les résultats. Tous les fournisseurs SCM affichent la requête HTTP et la réponse envoyées via le webhook dans leur interface utilisateur.
Si la tentative de connexion échoue, nous sommes redirigés vers la page d'erreur de connexion.

Mais si la **connexion réussit**, nous sommes redirigés vers la page principale de Jenkins, et un **cookie de session est défini**.

Ainsi, nous pouvons **forcer brutalement les identifiants Jenkins et obtenir un cookie de session !**
Cependant, nous sommes un peu limités - nous ne pouvons envoyer qu'une **requête sans état à chaque fois**, et le **cookie ne peut pas être attaché** à notre requête, car nous ne pouvons pas contrôler les en-têtes.

Une autre option serait d'essayer d'obtenir un **jeton d'accès Jenkins**, qui peut être attaché dans l'URL et utilisé pour envoyer des requêtes POST à Jenkins sans avoir besoin d'ajouter un jeton CSRF. Cette option est un peu plus complexe car elle nécessite qu'un attaquant trouve à la fois un CI auto-hébergé qui n'est accessible que depuis les plages d'IP SCM et obtienne également un jeton d'accès valide à ce CI. Donc pour le moment - nous nous concentrerons sur des scénarios plus pratiques.

## GitLab Webhooks

### Abuser de la Connexion Jenkins

Essayons d'envoyer la même requête, mais cette fois via GitLab. En raison des mêmes limitations, nous envoyons la **même requête POST exacte, en ajoutant les identifiants comme paramètres de requête**.

Nous déclenchons la requête, mais contrairement à GitHub – la réponse est 200. Comme dans le dernier exemple, nous avons utilisé **le service webhook de GitLab pour forcer brutalement un utilisateur et obtenir un cookie de session**, mais cette fois – le contenu de la réponse de Jenkins a été relayé à l'interface utilisateur de GitLab, nous fournissant essentiellement **le contenu complet de la page principale de Jenkins.**
C'est parce que **GitLab a suivi la redirection** en ajoutant le **Cookie** à la requête :

Cela signifie que nous pouvons :

1. forcer brutalement les utilisateurs et découvrir des identifiants valides,
2. utiliser les identifiants valides contre la page de connexion pour se connecter avec succès,
3. obtenir le contenu de la page principale interne de Jenkins.

### Obtenir des Données Internes de Jenkins

La **connexion Jenkins accepte un paramètre de redirection** – “_from_”. À l'origine utilisé pour **rediriger les utilisateurs vers la page qu'ils visaient après s'être connectés**, mais dans notre cas – une fonctionnalité que nous pouvons abuser pour envoyer une requête GET attachée avec un cookie de session à une page interne Jenkins de notre choix. Voyons comment :

1. Définissez un webhook avec l'URL suivante :
```
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=secretpass123&from=/job/prod_pipeline/1/consoleText&Submit=Sign+in
```
Une requête POST est envoyée à Jenkins, et l'authentification réussit.

* Nous obtenons une réponse de redirection 302, avec un cookie de session, et une redirection vers la page de sortie de la console de travail.
* Le service de webhook GitLab suit automatiquement la redirection avec une requête GET envoyée à la page de sortie de la console de travail, avec le cookie de session qui est ajouté à la requête :
```
http://jenkins.example-domain.com/job/prod_pipeline/1/consoleText
```
* La sortie de la console de tâche est renvoyée et présentée dans le journal d'événements de webhook GitLab de l'attaquant.

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

Il est important de mentionner ici que Jenkins peut être **configuré soit pour permettre l'accès aux composants internes sans authentification**, soit de manière à ce que seuls les utilisateurs authentifiés puissent accéder aux composants internes. Quel impact cela a-t-il sur nous ?

* S'il n'y a **pas d'authentification** configurée, nous pouvons faire en sorte que le **service de webhook GitLab accède à n'importe quelle page interne du CI**, capture la réponse et nous la présente.
* Si une authentification est configurée, nous pouvons essayer de forcer brutalement un utilisateur, puis utiliser les identifiants pour accéder à n'importe quelle page interne (comme dans le point ci-dessus).

<details>

<summary><strong>Apprenez le hacking AWS de zéro à héros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncée dans HackTricks** ou **télécharger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* Découvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** 💬 [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez**-moi sur **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux dépôts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
