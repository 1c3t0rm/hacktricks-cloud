# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnove iOS-a

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Testno Okruženje

Na ovoj stranici možete pronaći informacije o **iOS simulatoru**, **emulatorima** i **jailbreaking-u:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Početna Analiza

### Osnovne iOS Testne Operacije

Tokom testiranja će biti predložene **različite operacije** (povezivanje sa uređajem, čitanje/pisanje/otpisivanje/preuzimanje fajlova, korišćenje nekih alata...). Stoga, ako ne znate kako da izvršite bilo koju od ovih radnji, molimo vas da **počnete sa čitanjem stranice**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Za sledeće korake **aplikacija treba biti instalirana** na uređaju i trebalo bi već da ste dobili **IPA fajl** aplikacije.\
Pročitajte stranicu [Osnovne iOS Testne Operacije](basic-ios-testing-operations.md) da biste saznali kako to uraditi.
{% endhint %}

### Osnovna Statistička Analiza

Preporučuje se korišćenje alata [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) za automatsku Statističku Analizu IPA fajla.

Identifikacija **zaštita koje su prisutne u binarnom fajlu**:

* **PIE (Position Independent Executable)**: Kada je omogućeno, aplikacija se učitava na nasumičnu memorijsku adresu svaki put kada se pokrene, čime se otežava predviđanje njene početne memorijske adrese.

```bash
otool -hv <app-binary> | grep PIE   # Trebalo bi da uključuje zastavicu PIE
```

* **Stack Canaries**: Da bi se potvrdila celovitost steka, 'canary' vrednost se postavlja na stek pre poziva funkcije i ponovo se proverava kada funkcija završi.

```bash
otool -I -v <app-binary> | grep stack_chk   # Trebalo bi da uključuje simbole: stack_chk_guard i stack_chk_fail
```

* **ARC (Automatic Reference Counting)**: Da bi se sprečile uobičajene greške u korupciji memorije

```bash
otool -I -v <app-binary> | grep objc_release   # Trebalo bi da uključuje simbol _objc_release
```

* **Enkriptovan Binarni Fajl**: Binarni fajl treba da bude enkriptovan

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Cryptid treba da bude 1
```

**Identifikacija Osetljivih/Nesigurnih Funkcija**

* **Slabi Hashing Algoritmi**

```bash
# Na iOS uređaju
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Na linux-u
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

* **Nesigurne Random Funkcije**

```bash
# Na iOS uređaju
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Na linux-u
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

* **Nesigurna 'Malloc' Funkcija**

```bash
# Na iOS uređaju
otool -Iv <app> | grep -w "_malloc"

# Na linux-u
grep -iER "_malloc"
```

* **Nesigurne i Ranjive Funkcije**

```bash
# Na iOS uređaju
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Na linux-u
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Osnovna Dinamička Analiza

Pogledajte dinamičku analizu koju sprovodi [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Morate da navigujete kroz različite prikaze i interagujete sa njima, ali će povezivati nekoliko klasa i obavljati druge radnje, a izradiće izveštaj kada završite.

### Lista Instaliranih Aplikacija

Koristite komandu `frida-ps -Uai` da biste odredili **identifikator paketa** instaliranih aplikacija:

```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```

### Osnovna enumeracija i hakovanje

Naučite kako da **enumerišete komponente aplikacije** i kako lako da **hukujete metode i klase** pomoću objekcije:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Struktura IPA fajla

Struktura **IPA fajla** je suštinski kao **zipovanog paketa**. Preimenovanjem ekstenzije u `.zip`, može se **dekompresovati** da bi se otkrili njegovi sadržaji. Unutar ove strukture, **Bundle** predstavlja potpuno zapakovanu aplikaciju spremnu za instalaciju. Unutar, pronaći ćete direktorijum nazvan `<IME>.app`, koji enkapsulira resurse aplikacije.

* **`Info.plist`**: Ovaj fajl sadrži specifične konfiguracione detalje aplikacije.
* **`_CodeSignature/`**: Ovaj direktorijum uključuje plist fajl koji sadrži potpis, osiguravajući integritet svih fajlova u paketu.
* **`Assets.car`**: Kompresovani arhiv koji čuva fajlove resursa poput ikona.
* **`Frameworks/`**: Ovaj folder sadrži native biblioteke aplikacije, koje mogu biti u obliku `.dylib` ili `.framework` fajlova.
* **`PlugIns/`**: Ovde se mogu nalaziti proširenja aplikacije, poznata kao `.appex` fajlovi, iako nisu uvek prisutni.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Koristi se za čuvanje trajnih podataka vaše aplikacije za offline korišćenje, keširanje privremenih podataka i dodavanje funkcionalnosti poništavanja u vašu aplikaciju na jednom uređaju. Da sinhronizujete podatke na više uređaja u jednom iCloud nalogu, Core Data automatski reflektuje vašu šemu u CloudKit kontejneru.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Fajl `PkgInfo` je alternativni način za specificiranje tipa i kreator koda vaše aplikacije ili paketa.
* **en.lproj, fr.proj, Base.lproj**: Su jezički paketi koji sadrže resurse za te specifične jezike, i podrazumevani resurs u slučaju da jezik nije podržan.
* **Bezbednost**: Direktorijum `_CodeSignature/` igra ključnu ulogu u bezbednosti aplikacije verifikujući integritet svih zapakovanih fajlova putem digitalnih potpisa.
* **Upravljanje resursima**: Fajl `Assets.car` koristi kompresiju za efikasno upravljanje grafičkim resursima, što je ključno za optimizaciju performansi aplikacije i smanjenje njenog ukupnog obima.
* **Frameworks i PlugIns**: Ovi direktorijumi ističu modularnost iOS aplikacija, omogućavajući programerima da uključe biblioteke sa ponovno iskoristivim kodom (`Frameworks/`) i prošire funkcionalnost aplikacije (`PlugIns/`).
* **Lokalizacija**: Struktura podržava više jezika, olakšavajući globalni doseg aplikacije uključivanjem resursa za specifične jezičke pakete.

**Info.plist**

**Info.plist** služi kao osnova za iOS aplikacije, enkapsulišući ključne konfiguracione podatke u obliku **ključ-vrednost** parova. Ovaj fajl je obavezan ne samo za aplikacije već i za proširenja aplikacija i okvire upakovane unutar njih. Strukturiran je u XML ili binarnom formatu i sadrži ključne informacije koje se kreću od dozvola aplikacije do sigurnosnih konfiguracija. Za detaljno istraživanje dostupnih ključeva, može se referisati na [**Apple Developer dokumentaciju**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Za one koji žele da rade sa ovim fajlom u pristupačnijem formatu, konverzija u XML format može se postići lako korišćenjem `plutil` na macOS-u (dostupno nativno na verzijama 10.2 i kasnije) ili `plistutil` na Linux-u. Komande za konverziju su sledeće:

* **Za macOS**:

```bash
$ plutil -convert xml1 Info.plist
```

* **Za Linux**:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

Među mnoštvom informacija koje **Info.plist** datoteka može otkriti, značajni unosi uključuju niske dozvola aplikacije (`UsageDescription`), prilagođene URL šeme (`CFBundleURLTypes`), i konfiguracije za bezbednost transporta aplikacije (`NSAppTransportSecurity`). Ovi unosi, zajedno sa drugima poput izvoženih/uvezenih prilagođenih tipova dokumenata (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), mogu se lako pronaći inspekcijom datoteke ili korišćenjem jednostavne `grep` komande:

```bash
$ grep -i <keyword> Info.plist
```

**Putanje podataka**

U iOS okruženju, direktorijumi su posebno određeni za **sistemsku aplikaciju** i **aplikacije koje je instalirao korisnik**. Sistemski aplikacije se nalaze u direktorijumu `/Applications`, dok se aplikacije koje je instalirao korisnik smeštaju u `/private/var/containers/`. Ove aplikacije su dodeljene jedinstveni identifikator poznat kao **128-bitni UUID**, što čini zadatak ručnog lociranja foldera aplikacije izazovnim zbog nasumičnosti imena direktorijuma.

Kako bi olakšao otkrivanje direktorijuma instalacije aplikacije koju je instalirao korisnik, **objection alat** pruža korisnu komandu, `env`. Ova komanda otkriva detaljne informacije o direktorijumu za datu aplikaciju. U nastavku je primer kako koristiti ovu komandu:

```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```

Alternativno, ime aplikacije može biti pretraženo unutar `/private/var/containers` korišćenjem `find` komande:

```bash
find /private/var/containers -name "Progname*"
```

Komande poput `ps` i `lsof` takođe mogu biti iskorišćene za identifikaciju procesa aplikacije i listanje otvorenih fajlova, pružajući uvid u aktivne putanje direktorijuma aplikacije:

```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```

**Direktorijum paketa:**

* **AppName.app**
* Ovo je Aplikacioni Paket kao što je viđeno ranije u IPA, sadrži osnovne podatke aplikacije, statički sadržaj kao i kompilirani binarni fajl aplikacije.
* Ovaj direktorijum je vidljiv korisnicima, ali **korisnici ne mogu pisati u njega**.
* Sadržaj u ovom direktorijumu **nije rezervisan**.
* Sadržaj ovog foldera se koristi za **validaciju potpisa koda**.

**Direktorijum podataka:**

* **Documents/**
* Sadrži sve podatke koje je generisao korisnik. Korisnik aplikacije inicira kreiranje ovih podataka.
* Vidljiv korisnicima i **korisnici mogu pisati u njega**.
* Sadržaj u ovom direktorijumu je **rezervisan**.
* Aplikacija može onemogućiti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Sadrži sve **fajlove koji nisu specifični za korisnika**, kao što su **keševi**, **postavke**, **kolačići**, i fajlovi konfiguracije property list (plist).
* iOS aplikacije obično koriste poddirektorijume `Application Support` i `Caches`, ali aplikacija može kreirati prilagođene poddirektorijume.
* **Library/Caches/**
* Sadrži **polu-persistentne keširane fajlove**.
* Nevidljiv korisnicima i **korisnici ne mogu pisati u njega**.
* Sadržaj u ovom direktorijumu **nije rezervisan**.
* OS može automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je malo slobodnog prostora za skladištenje.
* **Library/Application Support/**
* Sadrži **persistentne fajlove** neophodne za pokretanje aplikacije.
* **Nevidljiv** **korisnicima** i korisnici ne mogu pisati u njega.
* Sadržaj u ovom direktorijumu je **rezervisan**.
* Aplikacija može onemogućiti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Koristi se za čuvanje svojstava koja mogu **persistirati čak i nakon restartovanja aplikacije**.
* Informacije se čuvaju, nešifrovane, unutar peska aplikacije u plist fajlu nazvanom \[BUNDLE\_ID].plist.
* Svi parovi ključ/vrednost sačuvani korišćenjem `NSUserDefaults` mogu se pronaći u ovom fajlu.
* **tmp/**
* Koristite ovaj direktorijum za pisanje **privremenih fajlova** koji ne moraju persistirati između pokretanja aplikacije.
* Sadrži ne-persistentne keširane fajlove.
* **Nevidljiv** korisnicima.
* Sadržaj u ovom direktorijumu nije rezervisan.
* OS može automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je malo slobodnog prostora za skladištenje.

Pogledajmo detaljnije Application Bundle (.app) direktorijum iGoat-Swift aplikacije unutar Bundle direktorijuma (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):

```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```

### Binarno Revertovanje

Unutar foldera `<ime-aplikacije>.app` pronaći ćete binarni fajl nazvan `<ime-aplikacije>`. Ovo je fajl koji će biti **izvršen**. Možete izvršiti osnovnu inspekciju binarnog fajla pomoću alata **`otool`**:

```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```

**Proverite da li je aplikacija enkriptovana**

Pogledajte da li postoji bilo kakav izlaz za:

```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```

**Rastavljanje binarnog koda**

Rastavite tekstualni deo:

```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```

Da biste odštampali **Objective-C segment** uzorka aplikacije, možete koristiti:

```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```

Da biste dobili kompaktniji Objective-C kod, možete koristiti [**class-dump**](http://stevenygard.com/projects/class-dump/):

```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```

Međutim, najbolje opcije za rastavljanje binarnog koda su: [**Hopper**](https://www.hopperapp.com/download.html?) i [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Skladištenje podataka

Da biste saznali kako iOS čuva podatke na uređaju, pročitajte ovu stranicu:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Sledeća mesta za skladištenje informacija treba proveriti **odmah nakon instaliranja aplikacije**, **nakon provere svih funkcionalnosti** aplikacije i čak nakon **odjavljivanja sa jednog korisnika i prijavljivanja sa drugog**.\
Cilj je pronaći **nezaštićene osetljive informacije** aplikacije (šifre, tokene), trenutnog korisnika i prethodno prijavljenih korisnika.
{% endhint %}

### Plist

**plist** fajlovi su strukturirani XML fajlovi koji **sadrže parove ključ-vrednost**. To je način za čuvanje trajnih podataka, pa ponekad možete pronaći **osetljive informacije u ovim fajlovima**. Preporučuje se provera ovih fajlova nakon instaliranja aplikacije i nakon intenzivnog korišćenja kako biste videli da li su upisani novi podaci.

Najčešći način za trajno čuvanje podataka u plist fajlovima je kroz korišćenje **NSUserDefaults**. Ovaj plist fajl se čuva unutar aplikacije u pesku u **`Library/Preferences/<appBundleID>.plist`**

Klasa [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) pruža programski interfejs za interakciju sa podrazumevanim sistemom. Podrazumevani sistem omogućava aplikaciji da prilagodi svoje ponašanje prema **korisničkim preferencama**. Podaci sačuvani pomoću `NSUserDefaults` mogu se pregledati u aplikacionom paketu. Ova klasa čuva **podatke** u **plist** **fajlu**, ali je namenjena za korišćenje sa malim količinama podataka.

Ovi podaci ne mogu direktno biti pristupljeni putem pouzdanog računara, ali se mogu pristupiti prilikom **bekapovanja**.

Možete **izvući** informacije sačuvane korišćenjem **`NSUserDefaults`** koristeći `ios nsuserdefaults get` u objection-u.

Da biste pronašli sve plist fajlove koje koristi aplikacija, možete pristupiti `/private/var/mobile/Containers/Data/Application/{APPID}` i pokrenuti:

```bash
find ./ -name "*.plist"
```

Za konvertovanje fajlova iz **XML ili binarnog (bplist)** formata u XML, dostupne su različite metode u zavisnosti od vašeg operativnog sistema:

**Za korisnike macOS-a:** Iskoristite `plutil` komandu. To je ugrađeni alat u macOS (verzija 10.2+), dizajniran za tu svrhu:

```bash
$ plutil -convert xml1 Info.plist
```

**Za korisnike Linux-a:** Prvo instalirajte `libplist-utils`, zatim koristite `plistutil` da konvertujete vaš fajl:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

**Unutar Objection sesije:** Za analizu mobilnih aplikacija, određena komanda vam omogućava da direktno konvertujete plist fajlove:

```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) je okvir za upravljanje slojem modela objekata u vašoj aplikaciji. [Core Data može koristiti SQLite kao svoje trajno skladište](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ali sam okvir nije baza podataka. CoreData ne šifrira podatke podrazumevano. Međutim, dodatni sloj šifrovanja može se dodati CoreData-u. Pogledajte [GitHub Repo](https://github.com/project-imas/encrypted-core-data) za više detalja.

Informacije o SQLite Core Data aplikaciji možete pronaći na putanji `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ako možete otvoriti SQLite i pristupiti osetljivim informacijama, onda ste pronašli grešku u konfiguraciji.**

{% code title="Kod iz iGoat-a" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) je skladište ključ/vrednost izgrađeno na vrhu SQLite-a.\
Pošto su Yap baze podataka sqlite baze podataka, možete ih pronaći koristeći namensku komandu iz prethodnog odeljka.

### Ostale SQLite baze podataka

Često se dešava da aplikacije kreiraju svoje sopstvene sqlite baze podataka. Mogu **čuvati** **osetljive** **podatke** na njima i ostaviti ih nešifrovane. Stoga je uvek interesantno proveriti svaku bazu podataka unutar direktorijuma aplikacije. Zato idite u direktorijum aplikacije gde su podaci sačuvani (`/private/var/mobile/Containers/Data/Application/{APPID}`).

```bash
find ./ -name "*.sqlite" -or -name "*.db"
```

### Firebase Real-Time Databases

Programeri su omogućeni da **skladište i sinhronizuju podatke** unutar **NoSQL cloud-hosted baze podataka** putem Firebase Real-Time baza podataka. Podaci se čuvaju u JSON formatu i sinhronizuju se sa svim povezanim klijentima u realnom vremenu.

Možete saznati kako da proverite da li su Firebase baze podataka netačno konfigurisane ovde:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm baze podataka

[Realm Objective-C](https://realm.io/docs/objc/latest/) i [Realm Swift](https://realm.io/docs/swift/latest/) nude moćnu alternativu za skladištenje podataka, što nije obezbeđeno od strane Apple-a. Podaci se podrazumevano **čuvaju nešifrovano**, sa mogućnošću enkripcije putem specifične konfiguracije.

Baze podataka se nalaze na: `/private/var/mobile/Containers/Data/Application/{APPID}`. Za istraživanje ovih fajlova, mogu se koristiti komande poput:

```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```

Za pregledanje ovih baza podataka preporučuje se alat [**Realm Studio**](https://github.com/realm/realm-studio).

Za implementaciju enkripcije unutar Realm baze podataka, može se koristiti sledeći kodni odlomak:

```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```

### Baze podataka Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) opisan je kao **lagani** i **ugrađeni** bazični motor koji sledi **orijentisan na dokumente** (NoSQL) pristup. Dizajniran da bude prirodan za **iOS** i **macOS**, nudi mogućnost sinhronizacije podataka bez problema.

Da biste identifikovali potencijalne Couchbase baze podataka na uređaju, treba pregledati sledeći direktorijum:

```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```

### Kolačići

iOS čuva kolačiće aplikacija u **`Library/Cookies/cookies.binarycookies`** unutar svake fascikle aplikacije. Međutim, programeri ponekad odluče da ih sačuvaju u **keychain-u** jer se pomenuti **fajl sa kolačićima može pristupiti u rezervnim kopijama**.

Da biste pregledali fajl sa kolačićima, možete koristiti [**ovaj Python skript**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ili koristiti objection-ovu komandu **`ios cookies get`.**\
**Takođe možete koristiti objection da** konvertujete ove fajlove u JSON format i pregledate podatke.

```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```

### Keš

Podrazumevano, NSURLSession čuva podatke, kao što su **HTTP zahtevi i odgovori u Cache.db** bazi podataka. Ova baza može sadržati **osetljive podatke**, ako su tokeni, korisnička imena ili bilo koje druge osetljive informacije keširane. Da biste pronašli keširane informacije, otvorite direktorijum podataka aplikacije (`/var/mobile/Containers/Data/Application/<UUID>`) i idite na `/Library/Caches/<Bundle Identifier>`. **WebKit keš se takođe čuva u Cache.db** fajlu. **Objection** može otvoriti i interagovati sa bazom podataka komandom `sqlite connect Cache.db`, jer je to **obična SQLite baza podataka**.

**Preporučuje se onemogućavanje keširanja ovih podataka**, jer može sadržati osetljive informacije u zahtevu ili odgovoru. U nastavku je prikazan spisak različitih načina postizanja ovoga:

1. Preporučuje se uklanjanje keširanih odgovora nakon odjave. To se može uraditi pomoću pružene metode od strane Apple-a nazvane [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) Možete pozvati ovu metodu na sledeći način:

`URLCache.shared.removeAllCachedResponses()`

Ova metoda će ukloniti sve keširane zahteve i odgovore iz Cache.db fajla. 2. Ako ne treba da koristite prednost kolačića, preporučuje se korišćenje svojstva [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) konfiguracije URLSession, što će onemogućiti čuvanje kolačića i keša.

[Apple dokumentacija](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Objekat konfiguracije sesije ephemeral je sličan objektu konfiguracije sesije po podrazumevanim vrednostima (videti default), osim što odgovarajući objekat sesije ne čuva kešove, skladišta akreditacija ili bilo koje podatke vezane za sesiju na disku. Umesto toga, podaci vezani za sesiju se čuvaju u RAM-u. Jedini put kada ephemeral sesija piše podatke na disk je kada joj kažete da zapiše sadržaj URL-a u fajl.` 3. Keš se takođe može onemogućiti postavljanjem Politike keširanja na [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). To će onemogućiti čuvanje keša na bilo koji način, bilo u memoriji ili na disku.

### Snimci

Kada pritisnete dugme za početni ekran, iOS **pravi snimak trenutnog ekrana** kako bi mogao da izvrši tranziciju ka aplikaciji na mnogo glađi način. Međutim, ako je **osetljivi** **podatak** prisutan na trenutnom ekranu, biće **sačuvan** u **slici** (koja **traje** **preko** **ponovnog pokretanja**). Ovo su snimci do kojih možete pristupiti i dvostrukim dodirivanjem početnog ekrana radi prebacivanja između aplikacija.

Osoba koja napada, osim ako je iPhone jailbroken, mora imati **pristup** **odblokiranom** uređaju da bi videla ove snimke ekrana. Podrazumevano, poslednji snimak se čuva u sandbox-u aplikacije u `Library/Caches/Snapshots/` ili `Library/SplashBoard/Snapshots` folderu (poverena računara ne mogu pristupiti fajl sistemu od iOX 7.0).

Jedan način da se spreči ovo loše ponašanje je postavljanje praznog ekrana ili uklanjanje osetljivih podataka pre pravljenja snimka korišćenjem funkcije `ApplicationDidEnterBackground()`.

U nastavku je prikazan primer metode za otklanjanje problema koji će postaviti podrazumevani snimak.

Swift:

```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```

Objective-C:

Cilj-C:

```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```

Ovo postavlja pozadinsku sliku na `overlayImage.png` kada se aplikacija prebaci u pozadinu. To sprečava curenje osetljivih podataka jer će `overlayImage.png` uvek zameniti trenutni prikaz.

### Keychain

Za pristupanje i upravljanje iOS kešom, dostupni su alati poput [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), pogodni za jailbroken uređaje. Dodatno, [**Objection**](https://github.com/sensepost/objection) pruža komandu `ios keychain dump` za slične svrhe.

#### **Čuvanje akreditacija**

Klasa **NSURLCredential** je idealna za čuvanje osetljivih informacija direktno u kešu, zaobilazeći potrebu za NSUserDefaults-om ili drugim omotačima. Za čuvanje akreditacija nakon prijave, koristi se sledeći Swift kod:

```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```

## **Prilagođene tastature i keš tastature**

Sa iOS 8.0 nadalje, korisnici mogu instalirati prilagođene tastaturne ekstenzije, koje su upravljive pod **Podešavanja > Opšte > Tastatura > Tastature**. Iako ove tastature nude proširene funkcionalnosti, predstavljaju rizik od beleženja pritisnutih tastera i slanja podataka eksternim serverima, iako korisnici dobijaju obaveštenje o tastaturama koje zahtevaju pristup mreži. Aplikacije mogu, i trebalo bi, ograničiti upotrebu prilagođenih tastatura za unos osetljivih informacija.

**Preporuke za bezbednost:**

* Preporučuje se onemogućavanje tastatura trećih strana radi poboljšane bezbednosti.
* Budite svesni funkcija automatske ispravke i automatskih predloga podrazumevane iOS tastature, koje mogu čuvati osetljive informacije u keš fajlovima smeštenim u `Library/Keyboard/{locale}-dynamic-text.dat` ili `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Ovi keš fajlovi trebalo bi redovno proveravati radi osetljivih podataka. Preporučuje se resetovanje rečnika tastature putem **Podešavanja > Opšte > Resetovanje > Resetovanje rečnika tastature** radi brisanja keširanih podataka.
* Presretanje mrežnog saobraćaja može otkriti da li prilagođena tastatura daljinski prenosi pritisnute tastere.

### **Prevencija keširanja polja za unos teksta**

Protokol [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) nudi osobine za upravljanje automatskom ispravkom i bezbednim unosom teksta, što je ključno za sprečavanje keširanja osetljivih informacija. Na primer, onemogućavanje automatske ispravke i omogućavanje bezbednog unosa teksta može se postići sa:

```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```

Dodatno, developeri treba da se pobrinu da tekstualna polja, posebno ona namenjena za unos osetljivih informacija poput lozinki i PIN-ova, onemoguće keširanje postavljanjem `autocorrectionType` na `UITextAutocorrectionTypeNo` i `secureTextEntry` na `YES`.

```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```

## **Logovi**

Debugiranje koda često uključuje korišćenje **logova**. Postoji rizik jer **logovi mogu sadržati osetljive informacije**. Ranije, u iOS 6 i starijim verzijama, logovi su bili dostupni svim aplikacijama, što je predstavljalo rizik od curenja osetljivih podataka. **Sada su aplikacije ograničene na pristup samo svojim logovima**.

Uprkos ovim ograničenjima, **napadač sa fizičkim pristupom** otključanom uređaju i dalje može iskoristiti ovo povezivanjem uređaja sa računarom i **čitanjem logova**. Važno je napomenuti da logovi ostaju na disku čak i nakon deinstalacije aplikacije.

Da bi se smanjili rizici, preporučuje se **temeljno interagovanje sa aplikacijom**, istražujući sve njene funkcionalnosti i ulaze kako bi se osiguralo da se slučajno ne beleže osetljive informacije.

Prilikom pregleda izvornog koda aplikacije radi potencijalnih curenja, potražite kako **unapred definisane** tako i **prilagođene izjave za logovanje** koristeći ključne reči poput `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` za ugrađene funkcije, kao i bilo kakve pomenute `Logging` ili `Logfile` za prilagođene implementacije.

### **Pratite Logove Sistemskog Nadzora**

Aplikacije beleže različite informacije koje mogu biti osetljive. Za praćenje ovih logova, alati i komande poput:

```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```

Su korisne. Dodatno, **Xcode** pruža način za prikupljanje konzolnih zapisa:

1. Otvorite Xcode.
2. Povežite iOS uređaj.
3. Idite na **Prozor** -> **Uređaji i Simulatori**.
4. Izaberite svoj uređaj.
5. Pokrenite problem koji istražujete.
6. Koristite dugme **Otvori konzolu** da biste pregledali zapise u novom prozoru.

Za naprednije beleženje, povezivanje sa ljuskom uređaja i korišćenje **socat**-a može omogućiti praćenje logova u realnom vremenu:

```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```

### Beleženje aktivnosti dnevnika

Prateći naredbe za posmatranje aktivnosti dnevnika, koje mogu biti od neprocenjive vrednosti za dijagnostikovanje problema ili identifikaciju potencijalnog curenja podataka u dnevnicima.

***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice na svetu.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Rezervne kopije

**Automatske funkcije rezervnog kopiranja** su integrisane u iOS, olakšavajući kreiranje kopija podataka uređaja putem iTunes-a (do macOS Catalina), Finder-a (od macOS Catalina nadalje) ili iCloud-a. Ove rezervne kopije obuhvataju gotovo sve podatke uređaja, isključujući visoko osetljive elemente poput detalja Apple Pay-a i konfiguracija Touch ID-a.

### Bezbednosni rizici

Uključivanje **instaliranih aplikacija i njihovih podataka** u rezervne kopije postavlja pitanje potencijalnog **curenja podataka** i rizika da **izmene rezervne kopije mogu promeniti funkcionalnost aplikacije**. Preporučuje se **ne čuvati osetljive informacije u običnom tekstu** unutar direktorijuma bilo koje aplikacije ili njenih poddirektorijuma kako bi se umanjili ovi rizici.

### Isključivanje datoteka iz rezervnih kopija

Datoteke u `Documents/` i `Library/Application Support/` se podrazumevano rezervišu. Razvojni programeri mogu isključiti određene datoteke ili direktorijume iz rezervnih kopija koristeći `NSURL setResourceValue:forKey:error:` sa `NSURLIsExcludedFromBackupKey`. Ova praksa je ključna za zaštitu osetljivih podataka od uključivanja u rezervne kopije.

### Testiranje ranjivosti

Da biste procenili sigurnost rezervne kopije aplikacije, počnite sa **kreiranjem rezervne kopije** koristeći Finder, a zatim je locirajte koristeći uputstva iz [zvanične dokumentacije kompanije Apple](https://support.apple.com/en-us/HT204215). Analizirajte rezervnu kopiju u potrazi za osetljivim podacima ili konfiguracijama koje bi mogle biti promenjene kako bi uticale na ponašanje aplikacije.

Osetljive informacije mogu se pronaći korišćenjem alata komandne linije ili aplikacija poput [iMazing](https://imazing.com). Za šifrovane rezervne kopije, prisustvo šifrovanja može se potvrditi proverom ključa "IsEncrypted" u fajlu "Manifest.plist" na korenu rezervne kopije.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```

Za rukovanje enkriptovanim rezervnim kopijama, Python skripte dostupne u [DinoSec-ovom GitHub repozitorijumu](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), poput **backup\_tool.py** i **backup\_passwd.py**, mogu biti korisne, iako potencijalno zahtevaju prilagođavanje za kompatibilnost sa najnovijim verzijama iTunes/Finder-a. [**iOSbackup** alat](https://pypi.org/project/iOSbackup/) je još jedna opcija za pristupanje fajlovima unutar zaštićenih lozinkom rezervnih kopija.

### Modifikacija Ponašanja Aplikacije

Primer modifikacije ponašanja aplikacije putem izmena u rezervnoj kopiji je prikazan u [Bither bitcoin novčanik aplikaciji](https://github.com/bither/bither-ios), gde se UI zaključavanje PIN-a čuva unutar `net.bither.plist` pod ključem **pin\_code**. Uklanjanje ovog ključa iz plist datoteke i vraćanje rezervne kopije uklanja zahtev za PIN-om, pružajući neograničen pristup.

## Rezime Testiranja Memorije za Osetljive Podatke

Kada se bavite osetljivim informacijama koje su smeštene u memoriji aplikacije, ključno je ograničiti vreme izlaganja ovih podataka. Postoje dva osnovna pristupa za istraživanje sadržaja memorije: **kreiranje dump-a memorije** i **analiza memorije u realnom vremenu**. Oba metoda imaju svoje izazove, uključujući potencijal da se propuste ključni podaci tokom procesa dump-a ili analize.

## **Dobijanje i Analiza Dump-a Memorije**

Za jailbroken i ne-jailbroken uređaje, alati poput [objection](https://github.com/sensepost/objection) i [Fridump](https://github.com/Nightbringer21/fridump) omogućavaju dump-ovanje memorije procesa aplikacije. Nakon što je dump-ovana, analiza ovih podataka zahteva različite alate, u zavisnosti od prirode informacija koje tražite.

Za izvlačenje stringova iz dump-a memorije, mogu se koristiti komande poput `strings` ili `rabin2 -zz`:

```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```

Za detaljniju analizu, uključujući pretragu određenih tipova podataka ili obrazaca, **radare2** nudi obimne mogućnosti pretrage:

```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```

## **Analiza memorije u toku izvršavanja**

**r2frida** pruža moćnu alternativu za inspekciju memorije aplikacije u realnom vremenu, bez potrebe za memorijskim ispuštanjem. Ovaj alat omogućava izvršavanje pretraga direktno na memoriji aplikacije koja se izvršava:

```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```

## Oštećena Kriptografija

### Slabi Procesi Upravljanja Ključevima

Neki programeri čuvaju osetljive podatke u lokalnom skladištu i šifriraju ih ključem koji je unapred definisan/predvidljiv u kodu. Ovo ne bi trebalo raditi jer neko ko vrši reverzni inženjering može izvući poverljive informacije.

### Korišćenje Nesigurnih i/ili Zastarelih Algoritama

Programeri ne bi trebalo da koriste **zastarele algoritme** za obavljanje **provera** autorizacije, **čuvanje** ili **slanje** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se **heševi** koriste za čuvanje lozinki na primer, trebalo bi koristiti heševe otporne na napade brute-force uz dodatak soli.

### Provera

Glavne provere koje treba obaviti su da li možete pronaći **unapred definisane** lozinke/tajne u kodu, ili da li su te lozinke **predvidljive**, i da li kod koristi neku vrstu **slabih** **kriptografskih** algoritama.

Zanimljivo je znati da možete **nadgledati** neke **kripto** **biblioteke** automatski koristeći **objection** sa:

```swift
ios monitor crypt
```

Za **više informacija** o iOS kriptografskim API-ima i bibliotekama posetite [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokalna Autentikacija

**Lokalna autentikacija** igra ključnu ulogu, posebno kada je u pitanju obezbeđivanje pristupa na udaljenom krajnjem tačkom putem kriptografskih metoda. Suština ovde je da bez pravilne implementacije, mehanizmi lokalne autentikacije mogu biti zaobiđeni.

Apple-ov [**Lokalni autentikacioni okvir**](https://developer.apple.com/documentation/localauthentication) i [**ključnik**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) pružaju snažne API-je programerima kako bi olakšali dijaloge autentikacije korisnika i sigurno rukovali tajnim podacima, redom. Secure Enclave obezbeđuje ID otiska prsta za Touch ID, dok se Face ID oslanja na prepoznavanje lica bez ugrožavanja biometrijskih podataka.

Da bi integrisali Touch ID/Face ID, programeri imaju dva API izbora:

* **`LocalAuthentication.framework`** za autentikaciju korisnika na visokom nivou bez pristupa biometrijskim podacima.
* **`Security.framework`** za pristup uslugama ključnika na nižem nivou, obezbeđujući tajne podatke biometrijskom autentikacijom. Različiti [omotači otvorenog koda](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) olakšavaju pristup ključniku.

{% hint style="info" %}
Međutim, kako `LocalAuthentication.framework` i `Security.framework` predstavljaju ranjivosti, pošto uglavnom vraćaju boolean vrednosti bez slanja podataka za autentikacione procese, čine ih podložnim zaobilaženju (videti [Ne dodiruj me na taj način, od strane Davida Lindnera i drugih](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementacija Lokalne Autentikacije

Da bi korisnike uputili na autentikaciju, programeri treba da koriste metodu **`evaluatePolicy`** unutar klase **`LAContext`**, birajući između:

* **`deviceOwnerAuthentication`**: Traži Touch ID ili šifru uređaja, neuspešno ako nijedno nije omogućeno.
* **`deviceOwnerAuthenticationWithBiometrics`**: Isključivo traži Touch ID.

Uspešna autentikacija se označava boolean vrednošću koja se vraća iz **`evaluatePolicy`**, ističući potencijalnu sigurnosnu manu.

### Lokalna Autentikacija korišćenjem Ključnika

Implementacija **lokalne autentikacije** u iOS aplikacijama uključuje korišćenje **ključničkih API-ja** za sigurno čuvanje tajnih podataka kao što su autentikacioni tokeni. Ovaj proces osigurava da podaci mogu biti pristupljeni samo od strane korisnika, korišćenjem šifre uređaja ili biometrijske autentikacije poput Touch ID-a.

Ključnik nudi mogućnost postavljanja stavki sa atributom `SecAccessControl`, koji ograničava pristup stavci dok korisnik uspešno autentikuje putem Touch ID-a ili šifre uređaja. Ova funkcija je ključna za unapređenje sigurnosti.

Ispod su primeri koda u Swift-u i Objective-C koji demonstriraju kako sačuvati i povratiti string u/iz ključnika, koristeći ove sigurnosne funkcije. Primeri posebno pokazuju kako postaviti kontrolu pristupa da zahteva autentikaciju putem Touch ID-a i osigura da su podaci dostupni samo na uređaju na kojem su postavljeni, pod uslovom da je konfigurisana šifra uređaja.

```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```

### Analiza statičkog koda

1. **Otvorite Xcode projekt**: Otvorite Xcode projekt koji želite da analizirate.
2. **Odaberite "Product"**: Kliknite na "Product" u glavnom meniju.
3. **Izaberite "Perform Action"**: Izaberite "Perform Action" i zatim "Build With...".
4. **Odaberite "Build For Profiling"**: Kliknite na "Build For Profiling" kako biste izgradili projekt za profilisanje.
5. **Pronađite izgrađeni fajl**: Pronađite izgrađeni fajl projekta koji želite da analizirate.
6. **Analizirajte fajl**: Koristite alate za analizu statičkog koda poput `otool`, `class-dump`, `Hopper`, ili `IDA Pro` za analizu izgrađenog fajla.

### Analiza dinamičkog koda

1. **Koristite LLDB debugger**: Koristite LLDB debugger za analizu dinamičkog koda vaše iOS aplikacije.
2. **Postavite tačke prekida**: Postavite tačke prekida na ključnim tačkama u kodu kako biste pratili izvršavanje.
3. **Pratite promenljive**: Pratite vrednosti promenljivih tokom izvršavanja aplikacije.
4. **Analizirajte mrežne zahteve**: Koristite alate poput Charles Proxy ili Burp Suite za analizu mrežnih zahteva i odgovora.
5. **Istražite memoriju**: Koristite alate poput `malloc_debug` za istraživanje memorije i otkrivanje curenja memorije ili drugih problema.

```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```

Sada možemo zatražiti sačuvanu stavku iz lanca ključeva. Usluge lanca ključeva će prikazati dijalog za autentifikaciju korisniku i vratiti podatke ili nil u zavisnosti da li je pružen odgovarajući otisak prsta ili ne.

```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```

### Analiza statičkog koda

1. **Otvorite Xcode projekt**: Otvorite Xcode projekt koji želite da analizirate.
2. **Odaberite "Product"**: Kliknite na "Product" u glavnom meniju.
3. **Izaberite "Perform Action"**: Izaberite "Perform Action" i zatim "Build With...".
4. **Odaberite "Build For Profiling"**: Kliknite na "Build For Profiling" kako biste izgradili projekt za profilisanje.
5. **Analizirajte rezultate**: Pregledajte rezultate analize statičkog koda kako biste identifikovali potencijalne sigurnosne ranjivosti.

### Analiza dinamičkog koda

1. **Koristite alate za analizu dinamičkog koda**: Koristite alate poput LLDB debuggera za analizu dinamičkog koda.
2. **Simulirajte napade**: Simulirajte različite scenarije napada kako biste identifikovali ranjivosti.
3. **Praćenje mrežnog saobraćaja**: Koristite alate poput Charles Proxy-a za praćenje i analizu mrežnog saobraćaja.
4. **Provera sigurnosnih mehanizama**: Proverite da li su implementirani sigurnosni mehanizmi poput enkripcije podataka i provere autentičnosti.

```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```

### Otkrivanje

Korišćenje okvira u aplikaciji takođe može biti otkriveno analizom liste deljenih dinamičkih biblioteka aplikacije. Ovo se može uraditi korišćenjem `otool`:

```bash
$ otool -L <AppName>.app/<AppName>
```

Ako se koristi `LocalAuthentication.framework` u aplikaciji, izlaz će sadržati obe sledeće linije (imajte na umu da `LocalAuthentication.framework` koristi `Security.framework` ispod haube):

```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```

### Bypass lokalnog autentikacionog okvira

#### **Prigovor**

Kroz **Prigovor Biometrijski Bypass**, koji se nalazi na [ovoj GitHub stranici](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), dostupna je tehnika za prevazilaženje mehanizma **LocalAuthentication**. Srž ovog pristupa uključuje korišćenje **Fride** za manipulaciju funkcije `evaluatePolicy`, osiguravajući da uvek daje rezultat `True`, bez obzira na stvarni uspeh autentikacije. Ovo je posebno korisno za zaobilaženje neispravnih biometrijskih autentikacionih procesa.

Za aktiviranje ovog bypass-a, koristi se sledeća komanda:

```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```

Ova komanda pokreće sekvencu u kojoj Objection registruje zadatak koji efikasno menja ishod provere `evaluatePolicy` na `True`.

#### Frida

Primer korišćenja **`evaluatePolicy`** iz aplikacije [DVIA-v2](https://github.com/prateek147/DVIA-v2):

```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```

Za postizanje **bypass**-a lokalne autentikacije, napisan je Frida skript. Ovaj skript cilja proveru **evaluatePolicy**, presrećući njen povratni poziv kako bi se osiguralo da vraća **success=1**. Menjanjem ponašanja povratnog poziva, provera autentikacije efikasno se zaobilazi.

Skript ispod je ubačen kako bi se izmenio rezultat metode **evaluatePolicy**. Menja rezultat povratnog poziva kako bi uvek pokazivao uspeh.

```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```

Da biste ubacili Frida skriptu i zaobišli biometrijsku autentikaciju, koristi se sledeća komanda:

```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```

## Otkrivanje Osetljive Funkcionalnosti Putem IPC

### Prilagođeni URI rukovaoci / Duboki linkovi / Prilagođene šeme

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Univerzalni Linkovi

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Deljenje

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### App Ekstenzije

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Veb Pregledači

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serijalizacija i Kodiranje

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Komunikacija Mreže

Važno je proveriti da li se neka komunikacija odvija **bez enkripcije** i takođe da li aplikacija pravilno **validira TLS sertifikat** servera.\
Da biste proverili ovakve probleme, možete koristiti proxy poput **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Provera Hostname-a

Jedan uobičajeni problem prilikom validacije TLS sertifikata je provera da li je sertifikat potpisan od strane **pouzdanog** **CA**, ali **ne proverava** da li je **hostname** sertifikata hostname koji se pristupa.\
Da biste proverili ovaj problem koristeći Burp, nakon što poverite Burp CA na iPhone-u, možete **kreirati novi sertifikat sa Burp-om za drugi hostname** i koristiti ga. Ako aplikacija i dalje radi, onda je nešto ranjivo.

### Pinovanje Sertifikata

Ako aplikacija pravilno koristi SSL Pinovanje, tada će aplikacija raditi samo ako je sertifikat onaj koji se očekuje. Prilikom testiranja aplikacije **ovo može biti problem jer će Burp poslužiti svoj sertifikat.**\
Da biste zaobišli ovu zaštitu unutar jailbroken uređaja, možete instalirati aplikaciju [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ili instalirati [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Takođe možete koristiti `ios sslpinning disable` iz **objection-a**.

## Razno

* U **`/System/Library`** možete pronaći okvire instalirane u telefonu koje koriste sistemski programi
* Aplikacije instalirane od strane korisnika iz App Store-a nalaze se unutar **`/User/Applications`**
* **`/User/Library`** sadrži podatke koje čuvaju aplikacije na nivou korisnika
* Možete pristupiti **`/User/Library/Notes/notes.sqlite`** da biste pročitali beleške sačuvane unutar aplikacije.
* Unutar fascikle instalirane aplikacije (**`/User/Applications/<APP ID>/`**) možete pronaći neke zanimljive datoteke:
  * **`iTunesArtwork`**: Ikona koju koristi aplikacija
  * **`iTunesMetadata.plist`**: Informacije o aplikaciji korišćene u App Store-u
  * **`/Library/*`**: Sadrži postavke i keš. U **`/Library/Cache/Snapshots/*`** možete pronaći snimak izvršen aplikaciji pre nego što je poslata u pozadinu.

### Brzo Popravljanje/Ažuriranje

Programeri mogu daljinski **popraviti sve instalacije svoje aplikacije odmah** bez potrebe da ponovo podnesu aplikaciju App Store-u i čekaju odobrenje.\
Za tu svrhu se obično koristi [**JSPatch**](https://github.com/bang590/JSPatch)**.** Ali postoje i druge opcije poput [Siren](https://github.com/ArtSabintsev/Siren) i [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Ovo je opasna mehanizam koji bi mogao biti zloupotrebljen od strane zlonamernih SDK-ova, stoga se preporučuje proveriti koji metod se koristi za automatsko ažuriranje (ako postoji) i testirati ga.** Možete pokušati da preuzmete prethodnu verziju aplikacije u tu svrhu.

### Treće Strane

Značajan izazov sa **SDK-ovima trećih strana** je **nedostatak granularne kontrole** nad njihovim funkcionalnostima. Programeri se suočavaju sa izborom: ili integrišu SDK i prihvate sve njegove funkcije, uključujući potencijalne sigurnosne ranjivosti i probleme privatnosti, ili potpuno odustanu od njegovih prednosti. Često, programeri nisu u mogućnosti da poprave ranjivosti unutar ovih SDK-ova sami. Štaviše, kako SDK-ovi stiču poverenje u zajednici, neki od njih mogu početi da sadrže zlonamerni softver.

Usluge koje pružaju SDK-ovi trećih strana mogu uključivati praćenje ponašanja korisnika, prikazivanje reklama ili poboljšanja korisničkog iskustva. Međutim, to uvodi rizik jer programeri možda nisu potpuno svesni koda koji se izvršava od strane ovih biblioteka, što dovodi do potencijalnih rizika po privatnost i sigurnost. Važno je ograničiti informacije koje se dele sa uslugama trećih strana na ono što je neophodno i osigurati da nijedni osetljivi podaci nisu izloženi.

Implementacija usluga trećih strana obično dolazi u dva oblika: samostalna biblioteka ili potpuni SDK. Da bi se zaštitila privatnost korisnika, svi podaci podeljeni sa ovim uslugama treba da budu **anonimizovani** kako bi se sprečilo otkrivanje lično identifikacionih informacija (PII).

Da bi se identifikovale biblioteke koje aplikacija koristi, može se koristiti komanda **`otool`**. Ovaj alat treba pokrenuti protiv aplikacije i svake deljene biblioteke koju koristi kako bi se otkrile dodatne biblioteke.

```bash
otool -L <application_path>
```

## **Reference & Dodatni Resursi**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS besplatni kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C verzija [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift verzija
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete radne tokove** pokretane najnaprednijim alatima zajednice na svetu.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**]\(https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
