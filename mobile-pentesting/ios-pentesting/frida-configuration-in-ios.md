# iOS Frida Configuration

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Instalacija Frida

**Koraci za instalaciju Frida na Jailbroken uređaju:**

1. Otvorite Cydia/Sileo aplikaciju.
2. Idite na Manage -> Sources -> Edit -> Add.
3. Unesite "https://build.frida.re" kao URL.
4. Idite na novo dodatu Frida izvor.
5. Instalirajte Frida paket.

Ako koristite **Corellium**, moraćete preuzeti Frida izdanje sa [https://github.com/frida/frida/releases](https://github.com/frida/frida/releases) (`frida-gadget-[yourversion]-ios-universal.dylib.gz`) i raspakovati i kopirati na lokaciju dylib koju Frida traži, npr.: `/Users/[youruser]/.cache/frida/gadget-ios.dylib`

Nakon instalacije, možete koristiti komandu **`frida-ls-devices`** na vašem računaru i proveriti da li se uređaj pojavljuje (vaš računar mora biti u mogućnosti da mu pristupi).\
Takođe izvršite i **`frida-ps -Uia`** da biste proverili pokrenute procese na telefonu.

## Frida bez Jailbroken uređaja i bez patchovanja aplikacije

Proverite ovaj blog post o tome kako koristiti Frida na uređajima koji nisu Jailbroken, bez patchovanja aplikacije: [https://mrbypass.medium.com/unlocking-potential-exploring-frida-objection-on-non-jailbroken-devices-without-application-ed0367a84f07](https://mrbypass.medium.com/unlocking-potential-exploring-frida-objection-on-non-jailbroken-devices-without-application-ed0367a84f07)

## Instalacija Frida klijenta

Instalirajte **frida alate**:

```bash
pip install frida-tools
pip install frida
```

Sa instaliranim Frida serverom i pokrenutim i povezanim uređajem, **proverite** da li klijent **radi**:

```bash
frida-ls-devices  # List devices
frida-ps -Uia     # Get running processes
```

## Frida Praćenje

Frida je moćan alat za praćenje i manipulaciju izvršavanja koda na mobilnim uređajima. Omogućava nam da pratimo i modifikujemo izvršavanje aplikacija u stvarnom vremenu. U ovom odeljku ćemo se fokusirati na Frida praćenje.

### Konfiguracija Frida Servera na iOS-u

Da bismo koristili Frida na iOS-u, prvo moramo konfigurisati Frida server na ciljnom uređaju. Evo koraka za konfiguraciju Frida servera na iOS-u:

1. Preuzmite Frida server za iOS sa [zvanične Frida GitHub stranice](https://github.com/frida/frida/releases).
2. Prebacite Frida server na ciljni iOS uređaj. Možete koristiti alate poput `scp` ili `sftp` za prenos datoteka na uređaj.
3. Na ciljnom uređaju, otvorite Terminal i navigirajte do direktorijuma u kojem se nalazi Frida server.
4. Pokrenite Frida server sa sledećom komandom:

```bash
./frida-server -l 0.0.0.0:1337
```

Napomena: Ova komanda pokreće Frida server na svim dostupnim mrežnim interfejsima na portu 1337. Možete promeniti IP adresu i port prema potrebama.

5. Frida server će se pokrenuti i prikazati informacije o adresi i portu na kojem je pokrenut.

### Povezivanje sa Frida Serverom

Nakon što smo konfigurisali Frida server na ciljnom iOS uređaju, možemo se povezati sa njim koristeći Frida CLI ili Frida Python API. Evo primera kako se povezati sa Frida serverom koristeći Frida CLI:

1. Instalirajte Frida CLI na svom računaru koristeći sledeću komandu:

```bash
pip install frida-tools
```

2. Povežite se sa Frida serverom koristeći sledeću komandu:

```bash
frida-ps -R
```

Ova komanda će prikazati listu pokrenutih procesa na ciljnom iOS uređaju.

### Praćenje izvršavanja koda

Kada smo uspešno povezani sa Frida serverom, možemo početi sa praćenjem izvršavanja koda na ciljnom iOS uređaju. Evo primera kako pratiti izvršavanje koda koristeći Frida CLI:

1. Prikazivanje liste pokrenutih procesa:

```bash
frida-ps -U
```

2. Izbor ciljnog procesa za praćenje:

```bash
frida -U -l <script.js> <process_name>
```

Napomena: `<script.js>` predstavlja putanju do Frida skripte koju želite da izvršite, a `<process_name>` je ime ciljnog procesa.

3. Frida će pokrenuti skriptu i početi sa praćenjem izvršavanja koda u ciljnom procesu.

### Zaključak

Frida je moćan alat za praćenje i manipulaciju izvršavanja koda na iOS uređajima. Konfiguracija Frida servera na ciljnom uređaju omogućava nam da se povežemo sa uređajem i pratimo izvršavanje koda u stvarnom vremenu. Korišćenje Frida CLI ili Frida Python API-a omogućava nam da pratimo izvršavanje koda i izvršavamo različite manipulacije na ciljnom uređaju.

```bash
# Functions
## Trace all functions with the word "log" in their name
frida-trace -U <program> -i "*log*"
frida-trace -U <program> -i "*log*" | swift demangle # Demangle names

# Objective-C
## Trace all methods of all classes
frida-trace -U <program> -m "*[* *]"

## Trace all methods with the word "authentication" from classes that start with "NE"
frida-trace -U <program> -m "*[NE* *authentication*]"

# Plug-In
## To hook a plugin that is momentarely executed prepare Frida indicating the ID of the Plugin binary
frida-trace -U -W <if-plugin-bin> -m '*[* *]'
```

### Dobijanje svih klasa i metoda

* Automatsko završavanje: Samo izvršite `frida -U <program>`

<figure><img src="../../.gitbook/assets/image (687).png" alt=""><figcaption></figcaption></figure>

* Dobijanje **svih** dostupnih **klasa** (filtrirano po stringu)

{% code title="/tmp/script.js" %}
```javascript
// frida -U <program> -l /tmp/script.js

var filterClass = "filterstring";

if (ObjC.available) {
for (var className in ObjC.classes) {
if (ObjC.classes.hasOwnProperty(className)) {
if (!filterClass || className.includes(filterClass)) {
console.log(className);
}
}
}
} else {
console.log("Objective-C runtime is not available.");
}
```
{% endcode %}

* Dobijte **sve** **metode** klase (filtrirajte po stringu)

{% code title="/tmp/script.js" %}
```javascript
// frida -U <program> -l /tmp/script.js

var specificClass = "YourClassName";
var filterMethod = "filtermethod";

if (ObjC.available) {
if (ObjC.classes.hasOwnProperty(specificClass)) {
var methods = ObjC.classes[specificClass].$ownMethods;
for (var i = 0; i < methods.length; i++) {
if (!filterMethod || methods[i].includes(filterClass)) {
console.log(specificClass + ': ' + methods[i]);
}
}
} else {
console.log("Class not found.");
}
} else {
console.log("Objective-C runtime is not available.");
}
```
{% endcode %}

* **Pozovi funkciju**

```javascript
// Find the address of the function to call
const func_addr = Module.findExportByName("<Prog Name>", "<Func Name>");
// Declare the function to call
const func = new NativeFunction(
func_addr,
"void", ["pointer", "pointer", "pointer"], {
});

var arg0 = null;

// In this case to call this function we need to intercept a call to it to copy arg0
Interceptor.attach(wg_log_addr, {
onEnter: function(args) {
arg0 = new NativePointer(args[0]);
}
});

// Wait untill a call to the func occurs
while (! arg0) {
Thread.sleep(1);
console.log("waiting for ptr");
}


var arg1 = Memory.allocUtf8String('arg1');
var txt = Memory.allocUtf8String('Some text for arg2');
wg_log(arg0, arg1, txt);

console.log("loaded");
```

## Frida Fuzzing

### Frida Stalker

[Od dokumentacije](https://frida.re/docs/stalker/): Stalker je Fridin **tracing engine**. Omogućava praćenje niti, hvatanje svake funkcije, svakog bloka, čak i svake instrukcije koja se izvršava.

Imate primer implementacije Frida Stalker-a na [https://github.com/poxyran/misc/blob/master/frida-stalker-example.py](https://github.com/poxyran/misc/blob/master/frida-stalker-example.py)

Ovo je još jedan primer za povezivanje Frida Stalker-a svaki put kada se pozove funkcija:

```javascript
console.log("loading");
const wg_log_addr = Module.findExportByName("<Program>", "<function_name>");
const wg_log = new NativeFunction(
wg_log_addr,
"void", ["pointer", "pointer", "pointer"], {
});

Interceptor.attach(wg_log_addr, {
onEnter: function(args) {
console.log(`logging the following message: ${args[2].readCString()}`);

Stalker.follow({
events: {
// only collect coverage for newly encountered blocks
compile: true,
},
onReceive: function (events) {
const bbs = Stalker.parse(events, {
stringify: false,
annotate: false
});
console.log("Stalker trace of write_msg_to_log: \n" + bbs.flat().map(DebugSymbol.fromAddress).join('\n'));
}
});
},
onLeave: function(retval) {
Stalker.unfollow();
Stalker.flush();  // this is important to get all events
}
});
```

{% hint style="danger" %}
Ovo je zanimljivo u svrhu otklanjanja grešaka, ali za fuzzing, stalno koristiti **`.follow()`** i **`.unfollow()`** je veoma neefikasno.
{% endhint %}

## [Fpicker](https://github.com/ttdennis/fpicker)

[**fpicker**](https://github.com/ttdennis/fpicker) je **Frida baziran alat za fuzzing** koji nudi različite režime fuzzinga za fuzzing unutar procesa, kao što su AFL++ režim ili pasivni režim praćenja. Trebao bi raditi na svim platformama koje podržava Frida.

* [**Instaliraj fpicker**](https://github.com/ttdennis/fpicker#requirements-and-installation) **& radamsa**

```bash
# Get fpicker
git clone https://github.com/ttdennis/fpicker
cd fpicker

# Get Frida core devkit and prepare fpicker
wget https://github.com/frida/frida/releases/download/16.1.4/frida-core-devkit-16.1.4-[yourOS]-[yourarchitecture].tar.xz
# e.g. https://github.com/frida/frida/releases/download/16.1.4/frida-core-devkit-16.1.4-macos-arm64.tar.xz
tar -xf ./*tar.xz
cp libfrida-core.a libfrida-core-[yourOS].a #libfrida-core-macos.a

# Install fpicker
make fpicker-[yourOS] # fpicker-macos
# This generates ./fpicker

# Install radamsa (fuzzer generator)
brew install radamsa
```

* **Priprema fajl sistema:**

```bash
# From inside fpicker clone
mkdir -p examples/wg-log # Where the fuzzing script will be
mkdir -p examples/wg-log/out # For code coverage and crashes
mkdir -p examples/wg-log/in # For starting inputs

# Create at least 1 input for the fuzzer
echo Hello World > examples/wg-log/in/0
```

* **Fuzzer skripta** (`examples/wg-log/myfuzzer.js`):

{% code title="examples/wg-log/myfuzzer.js" %}
```javascript
// Import the fuzzer base class
import { Fuzzer } from "../../harness/fuzzer.js";

class WGLogFuzzer extends Fuzzer {

constructor() {
console.log("WGLogFuzzer constructor called")

// Get and declare the function we are going to fuzz
var wg_log_addr = Module.findExportByName("<Program name>", "<func name to fuzz>");
var wg_log_func = new NativeFunction(
wg_log_addr,
"void", ["pointer", "pointer", "pointer"], {
});

// Initialize the object
super("<Program nane>", wg_log_addr, wg_log_func);
this.wg_log_addr = wg_log_addr; // We cannot use "this" before calling "super"

console.log("WGLogFuzzer in the middle");

// Prepare the second argument to pass to the fuzz function
this.tag = Memory.allocUtf8String("arg2");

// Get the first argument we need to pass from a call to the functino we want to fuzz
var wg_log_global_ptr = null;
console.log(this.wg_log_addr);
Interceptor.attach(this.wg_log_addr, {
onEnter: function(args) {
console.log("Entering in the function to get the first argument");
wg_log_global_ptr = new NativePointer(args[0]);
}
});

while (! wg_log_global_ptr) {
Thread.sleep(1)
}
this.wg_log_global_ptr = wg_log_global_ptr;
console.log("WGLogFuzzer prepare ended")
}


// This function is called by the fuzzer with the first argument being a pointer into memory
// where the payload is stored and the second the length of the input.
fuzz(payload, len) {
// Get a pointer to payload being a valid C string (with a null byte at the end)
var payload_cstring = payload.readCString(len);
this.payload = Memory.allocUtf8String(payload_cstring);

// Debug and fuzz
this.debug_log(this.payload, len);
// Pass the 2 first arguments we know the function needs and finally the payload to fuzz
this.target_function(this.wg_log_global_ptr, this.tag, this.payload);
}
}

const f = new WGLogFuzzer();
rpc.exports.fuzzer = f;
```
{% endcode %}

* **Kompajlirajte** fuzzer:

```bash
# From inside fpicker clone
## Compile from "myfuzzer.js" to "harness.js"
frida-compile examples/wg-log/myfuzzer.js -o harness.js
```

* Pozovite fuzzer **`fpicker`** koristeći **`radamsa`**:

{% code overflow="wrap" %}
```bash
# Indicate fpicker to fuzz a program with the harness.js script and which folders to use
fpicker -v --fuzzer-mode active -e attach -p <Program to fuzz> -D usb -o examples/wg-log/out/ -i examples/wg-log/in/ -f harness.js --standalone-mutator cmd --mutator-command "radamsa"
# You can find code coverage and crashes in examples/wg-log/out/
```
{% endcode %}

{% hint style="danger" %}
U ovom slučaju **ne restartujemo aplikaciju ili ne vraćamo stanje** nakon svakog payloada. Dakle, ako Frida pronađe **pad aplikacije**, **sledeći unosi** nakon tog payloada takođe mogu **pokrenuti pad aplikacije** (jer je aplikacija u nestabilnom stanju), čak i ako **unos ne bi trebao izazvati pad aplikacije**.

Osim toga, Frida će se povezati sa signalima izuzetaka iOS-a, pa kada **Frida pronađe pad aplikacije**, verovatno neće biti generisani **izveštaji o padu iOS-a**.

Da bismo to sprečili, na primer, možemo restartovati aplikaciju nakon svakog Frida pada.
{% endhint %}

### Dnevnici i padovi

Možete proveriti **macOS konzolu** ili **`log`** cli da biste proverili macOS dnevnike.\
Takođe možete proveriti dnevnike sa iOS-a koristeći **`idevicesyslog`**.\
Neki dnevnici će izostaviti informacije dodavanjem **`<private>`**. Da biste prikazali sve informacije, morate instalirati neki profil sa [https://developer.apple.com/bug-reporting/profiles-and-logs/](https://developer.apple.com/bug-reporting/profiles-and-logs/) da biste omogućili te privatne informacije.

Ako ne znate šta da radite:

```sh
vim /Library/Preferences/Logging/com.apple.system.logging.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>Enable-Private-Data</key>
<true/>
</dict>
</plist>

killall -9 logd
```

Možete proveriti rušenja u:

* **iOS**
* Podešavanja → Privatnost → Analitika i poboljšanja → Analitički podaci
* `/private/var/mobile/Library/Logs/CrashReporter/`
* **macOS**:
* `/Library/Logs/DiagnosticReports/`
* `~/Library/Logs/DiagnosticReports`

{% hint style="warning" %}
iOS čuva samo 25 rušenja iste aplikacije, pa morate to očistiti ili će iOS prestati da pravi rušenja.
{% endhint %}

## Frida Android tutorijali

{% content-ref url="../android-app-pentesting/frida-tutorial/" %}
[frida-tutorial](../android-app-pentesting/frida-tutorial/)
{% endcontent-ref %}

## Reference

* [https://www.briskinfosec.com/blogs/blogsdetail/Getting-Started-with-Frida](https://www.briskinfosec.com/blogs/blogsdetail/Getting-Started-with-Frida)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **oglašavanje vaše kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
